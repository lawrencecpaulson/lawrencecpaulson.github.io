---
layout: post
title:  "Type classes versus Locales"
usemathjax: true 
tags: Isabelle, type classes, locales
---

As we've seen in an [earlier post]({% post_url 2022-03-02-Type_classes %}), type classes are a convenient mechanism for managing the overloading of syntax in a principled manner: types share syntax where they share the associated properties. For example, the familiar arithmetic operators share commutative, distributive and other laws on numeric types as different as the integers and the complex numbers. 
We also saw how to introduce a new type and quickly bring it "into the fold" of arithmetic types through a few type class instance declarations, in the case of the [quaternions]({% post_url 2022-03-09-Quaternions %}).
The main limitation of type classes is that the syntax and properties are associated with a type, and in only one way. A more general mechanism for packaging up syntax and related properties is locales. In particular, with locales we can finally make sense of abstract algebra.

### The problem of multiple instantiations

For an example of "only one way", consider the various ways to impose an ordering on lists, inherited from ordering on list elements. (Think of strings over an alphabet.)
There is the usual lexicographic ordering where $b > ab > aab > \cdots$, or the version where the length of the string dominant (so now $b < ab$). Both are total orderings
and they are incompatible, so it is impossible for a single development to involve both.
Similarly, sets have as an obvious partial ordering the subset relation, from which they inherit the distributed lattice of unions and intersections. But we often want to use other orderings with sets.

But the big problem, as mentioned earlier, is that type classes constrain types. That makes them useless for things that are not types, such as groups.
Locales solve this problem, so what are they?

### Locales: the basics

I ought to know everything about locales, because I was [there at the beginning](https://www.cl.cam.ac.uk/~lp15/papers/Isabelle/Locales-TPHOLs99.pdf).
But I feel like somebody who discovered that you can move a megalith if you roll it on logs and is now asked to explain the workings of a Tesla.
Anyway, I'd like to stress one thing: locales are not an extension of higher-order logic but rather syntactic support within Isabelle for managing logical contexts, which correspond logically to nothing more exotic than predicate symbols.

One of the early motivations of locales was to assist in the structuring of large proofs. Typically the context is extended with various abstract objects about which assumptions are made, and these contexts are then further extended. Before the era of structured proofs, each claim was established as a "theorem" in its right and proved with no more than half a dozen apply commands. The idea of packaging up such contexts could clearly be helpful. However, this particular problem had a much better solution: the Isar structured proof language, where a proof of any length could legibly be written out with as many nested contexts as anybody could want.

But another motivation was evident at the very beginning: to formalise abstract algebra, groups, rings, fields, etc.
More generally, a structure is a tuple consisting of one or more carrier sets bundled with a number of operations satisfying various laws. This can straightforwardly be represented by a logical predicate. In many cases, the underlying type of the carrier sets will either be obvious or can be a parameter of the locale. The power of locales comes from the support Isabelle provides for locale hierarchies, including multiple inheritance, and attached notations. A locale can be seen as a portable context that can be re-entered when needed, bringing with it associated syntax and facts. If this sounds similar to type classes, it's because type classes are actually implemented as a [special case of locales](https://doi.org/10.1007/978-3-540-74464-1_11).


### Postscript

Despite the limitations of type classes, it's worth noting that the Isabelle distribution and its Archive of Formal Proofs contains more than 4000 type class instance declarations.

For a thorough introduction to locales, see Ballarin's ["Tutorial to Locales and Locale Interpretation"](https://isabelle.in.tum.de/dist/Isabelle/doc/locales.pdf).
It's directly available from the documentation panel of your jEdit session.
He also wrote a [journal article](https://link.springer.com/article/10.1007/s10817-013-9284-7).

