---
layout: post
title:  "Formalising Ramsey theory, II"
usemathjax: true
tags: Isabelle, Ramsey's theorem, Erdős, ordinal partitions
---

Unlike the natural sciences, which are confined to what actually exists in the universe, mathematics is limited only by our imagination.
Some branches, such as number theory, attract much attention, while other topics languish in the fringes.
One fringe topic is *Ramsey theory*, and if anybody has heard of it, it's probably because it captured the attention of one of mathematics' few celebrities: Paul Erdős.
A [previous post]({% post_url 2021-12-29-Ramsey-1 %}) introduced Ramsey's theorem itself. It's reasonably well known and has significant applications.
Things get more obscure when we move into the transfinite.
In the sequel, you need to be familiar with ordinals, 
including [ordinal arithmetic](https://en.wikipedia.org/wiki/Ordinal_arithmetic) and [order types](https://en.wikipedia.org/wiki/Order_type).

### A brief introduction to ordinal partitions

As previously mentioned, the infinite version of Ramsey's theorem states that if $n$ is a positive integer and we partition the $n$-element subsets of a given infinite set $X$ into two parts, then there is an infinite subset $Y\subseteq X$ such that every $n$-subset of $Y$ is in the same part. 
Often $n=2$, when we can use the more intuitive terminology of graphs.
If the edges of the complete graph on $X$—an infinite set of vertices—are coloured black or white, then there is an infinite subset $Y\subseteq X$ such that all edges between elements of $Y$ have the same colour: are *monochromatic*.

The *partition notation* of Erdős and Rado, written $\alpha\longrightarrow (\beta_0, \ldots,\beta_{k-1})$,
means that for every partition of the set $[\alpha]^2$ (the ediges of the complete graph on $\alpha$) into $k$ colours $C_0$, $\ldots$, $C_{k-1}$, there exists $i<k$ and a subset $B\subseteq\alpha$ of order type $\beta_i$ such that $[B]^2\subseteq C_i$. 
In particular, the infinite version of Ramsey's theorem can be expressed by $\omega\longrightarrow (\omega ,\omega)$.
The negation of $\alpha\longrightarrow (\beta, \gamma)$ is written $\alpha \not\mkern-3mu\longrightarrow (\beta, \gamma)$.

One key result is negative: for any ordinal $\alpha$ we have $\alpha\not\mkern-3mu\longrightarrow (\|\alpha\|+1, \omega)$.
The proof involves an elementary construction that we'll formalise below.

In 1987, Erdős offered a thousand-dollar prize to anyone who could characterise the set of all countable ordinals $\alpha$ such that $\alpha\longrightarrow(\alpha,3)$.
Progress has been slow. My colleagues and I have formalised the proof important result,
$\omega^\omega\longrightarrow(\omega^\omega, m)$.
Unfortunately, such proofs tend to be gruesomely technical and all I can offer today is the elementary negative result mentioned above.

### Ordinal partitions in Isabelle/HOL

Our formalisation relies on the Isabelle/HOL [library for ZFC]({% post_url 2022-04-06-ZFC_in_HOL %}) set theory.
We use ordinary HOL sets to represent ralations and HOL sets, while the list of order types is a `V list`, combining ZF set theory with HOL lists.
Although we could encode lists directly as ZF sets, such combinations of the set theory and Isabelle/HOL libraries are the easiest way to accomplish what we want.

We begin by defining the Erdős–Rado partition notation. In its most general form, it accepts as an argument the relation to be used in the determination of order types. In many cases however, we'll specialise it to the standard ordering on set-theoretic ordinals (which is simply the membership relation).

<pre class="source">
<span class="keyword1 command">definition</span> <span class="entity">partn_lst</span> <span class="main">::</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">[</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> set<span class="main">,</span> <span class="tfree">'a</span> set<span class="main">,</span> V</span> list<span class="main">,</span> nat<span class="main">]</span> <span class="main">⇒</span> bool<span>"</span></span>
  <span class="keyword2 keyword">where</span> <span class="quoted"><span class="quoted"><span>"</span><span class="free">partn_lst</span> <span class="free bound entity">r</span> <span class="free bound entity">B</span> <span class="free bound entity">α</span> <span class="free bound entity">n</span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">f</span> <span class="main">∈</span> <span class="main">[</span></span><span class="free bound entity">B</span><span>]⇗</span><span class="free bound entity">n</span><span>⇖  </span><span class="main">→</span></span>  <span class="main">{..&lt;</span>length <span class="free bound entity">α</span><span class="main">}</span><span class="main">.</span>
              <span class="main">∃</span><span class="bound bound">i</span> <span class="main">&lt;</span> length <span class="free bound entity">α</span><span class="main">.</span> <span class="main">∃</span><span class="bound">H</span><span class="main">.</span> <span class="bound">H</span> <span class="main">⊆</span> <span class="free bound entity">B</span> <span class="main">∧</span> ordertype <span class="bound">H</span> <span class="free bound entity">r</span> <span class="main">=</span> <span class="main">(</span><span class="free bound entity">α</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">f</span> <span class="main">`</span> <span class="main">(</span>nsets <span class="bound">H</span> <span class="free bound entity">n</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">i</span><span class="main">}</span><span>"</span>
</pre>

This definition uses a lot of Isabelle/HOL syntax. Essentially it says that for every $f$ mapping $n$-element subsets of $B$ to natural numbers less than length$(\alpha)$, there exists some $i$ and $H$ where $H$ has order type $\alpha_i$.
The final inclusion, using the image operator, states that $f$ maps all $n$-element subsets of $H$ to $i$.

Here's a small example: proving the infinite version of Ramsey's theorem as $\omega\longrightarrow (\omega ,\omega)$, given a different formulation of that theorem.
So all that's happening in the proof below is the unpacking of the Erdős–Rado partition notation (in the ordinal version just mentioned) followed by an application of Ramsey's theorem and delivering the result in the required form.

<pre class="source">
<span class="keyword1 command">lemma</span> Ramsey_partn<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>partn_lst_VWF</span> ω</span> <span class="main">[</span>ω<span class="main">,</span>ω<span class="main">]</span> <span class="numeral">2</span><span>"</span>
<span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> partn_lst_def<span class="main">)</span>
  <span class="keyword3 command">fix</span> <span class="skolem">f</span>
  <span class="keyword3 command">assume</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">f</span> <span class="main">∈</span> <span class="main">[</span></span>elts</span> ω<span>]⇗</span><span class="numeral">2</span><span>⇖ </span><span class="main">→</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span><span class="main">}</span><span>"</span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> *<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>elts</span> ω</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>elts ω<span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="skolem">f</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">}</span> <span class="main">&lt;</span> <span class="numeral">2</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> nsets_def eval_nat_numeral<span class="main">)</span>
  <span class="keyword3 command">obtain</span> <span class="skolem skolem">H</span> <span class="skolem skolem">i</span> <span class="keyword2 keyword">where</span> H<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">H</span> <span class="main">⊆</span> elts</span> ω</span><span>"</span> <span class="keyword2 keyword">and</span> <span class="quoted quoted"><span>"</span>infinite <span class="skolem">H</span><span>"</span></span>
    <span class="keyword2 keyword">and</span> t<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">i</span> <span class="main">&lt;</span> Suc <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span><span>"</span></span>
    <span class="keyword2 keyword">and</span> teq<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">H</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">H</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="skolem">f</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">i</span><span>"</span></span>
    <span class="keyword1 command">using</span> Ramsey2 <span class="main">[</span><span class="operator">OF</span> infinite_ω *<span class="main">]</span> <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> eval_nat_numeral<span class="main">)</span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span>tp</span> <span class="skolem">H</span> <span class="main">=</span> <span class="main">[</span>ω</span><span class="main">,</span> ω<span class="main">]</span> <span class="main">!</span> <span class="skolem">i</span><span>"</span>
    <span class="keyword1 command">using</span> less_2_cases eval_nat_numeral ordertype_infinite_ω <span class="keyword1 command">by</span> <span class="operator">force</span>
  <span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="skolem">f</span> <span class="main">`</span> <span class="main">{</span><span class="bound">N</span><span class="main">.</span> <span class="bound">N</span> <span class="main">⊆</span> <span class="skolem">H</span> <span class="main">∧</span> finite <span class="bound">N</span> <span class="main">∧</span> card <span class="bound">N</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> teq card_2_iff<span class="main">)</span>
  <span class="keyword1 command">ultimately</span> <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">f</span> <span class="main">`</span> <span class="main">[</span></span><span class="skolem">H</span><span>]⇗</span><span class="numeral">2</span><span>⇖ </span><span class="main">⊆</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> <span class="main main">(</span>no_types<span class="main main">)</span> nsets_def numeral_2_eq_2<span class="main">)</span>
  <span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">∃</span><span class="bound bound">i</span><span class="main">&lt;</span>Suc <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound bound">H</span><span class="main">⊆</span>elts</span> ω</span><span class="main">.</span> tp <span class="bound">H</span> <span class="main">=</span> <span class="main">[</span>ω<span class="main">,</span>ω<span class="main">]</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">∧</span> <span class="skolem">f</span> <span class="main">`</span> <span class="main">[</span><span class="bound">H</span><span>]⇗</span><span class="numeral">2</span><span>⇖ </span><span class="main">⊆</span> <span class="main">{</span><span class="bound">i</span><span class="main">}</span><span>"</span>
    <span class="keyword1 command">using</span> H <span class="quoted"><span class="quoted"><span>‹</span>tp</span> <span class="skolem">H</span> <span class="main">=</span> <span class="main">[</span>ω</span><span class="main">,</span> ω<span class="main">]</span> <span class="main">!</span> <span class="skolem">i</span><span>›</span> t <span class="keyword1 command">by</span> <span class="operator">blast</span>
<span class="keyword1 command">qed</span>
</pre>

The form of the supplied version of Ramsey's theorem (`Ramsey2`, since it's for the $n=2$ case) should be evident from the <span class="keyword3 command">obtain</span> line.

### A negative result

To prove $\alpha\not\mkern-3mu\longrightarrow (\|\alpha\|+1, \omega)$ for any ordinal $\alpha$,
we construct a counterexample to the Ramsey property. The proof is simple enough to present in full. We begin by stating the claim.

<pre class="source">
<span class="keyword1 command">proposition</span> omega_basic_counterexample<span class="main">:</span>
  <span class="keyword2 keyword">assumes</span> <span class="quoted"><span class="quoted"><span>"</span>Ord</span> <span class="free">α</span><span>"</span></span>
  <span class="keyword2 keyword">shows</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">¬</span> partn_lst_VWF</span> <span class="free">α</span> <span class="main">[</span>succ</span> <span class="main">(</span>vcard <span class="free">α</span><span class="main">)</span><span class="main">,</span> ω<span class="main">]</span> <span class="numeral">2</span><span>"</span>
<span class="keyword1 command">proof</span> <span class="operator">-</span>
</pre>

The first step of the construction is to obtain an injective map $\pi: \alpha\to \|\alpha\|$, which exists because there is a bijection between any set and its cardinality. 
Since cardinals are certain ordinals and ordinals are certain sets, $\pi$ is simply a map from sets to sets.

<pre class="source">
  <span class="keyword3 command">obtain</span> <span class="skolem skolem">π</span> <span class="keyword2 keyword">where</span> funπ<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">π</span> <span class="main">∈</span> elts</span> <span class="free">α</span> <span class="main">→</span></span> elts <span class="main">(</span>vcard <span class="free">α</span><span class="main">)</span><span>"</span> <span class="keyword2 keyword">and</span> injπ<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>inj_on <span class="skolem">π</span> <span class="main">(</span>elts</span> <span class="free">α</span><span class="main">)</span><span>"</span></span>
    <span class="keyword1 command">using</span> inj_into_vcard <span class="keyword1 command">by</span> <span class="operator">auto</span>
  <span class="keyword1 command">have</span> Ordπ<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>Ord</span> <span class="main">(</span><span class="skolem">π</span> <span class="skolem">x</span><span class="main">)</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">x</span> <span class="main">∈</span> elts</span> <span class="free">α</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">x</span>
    <span class="keyword1 command">using</span> Ord_in_Ord funπ that <span class="keyword1 command">by</span> <span class="operator">fastforce</span>
</pre>

<pre class="source">
  <span class="keyword3 command">define</span> <span class="skolem skolem">f</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">f</span> <span class="skolem">A</span> <span class="main">≡</span> <span class="main">@</span><span class="bound">i</span><span class="main">::</span>nat<span class="main">.</span> <span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="skolem">A</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">}</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">π</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="skolem">π</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">i</span><span class="main">=</span><span class="main">0</span> <span class="main">∨</span> <span class="skolem">π</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">π</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">i</span><span class="main">=</span><span class="main">1</span><span class="main">)</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">A</span>
  <span class="keyword1 command">have</span> f_Pi<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">f</span> <span class="main">∈</span> <span class="main">[</span></span>elts</span> <span class="free">α</span><span>]⇗</span><span class="numeral">2</span><span>⇖ </span><span class="main">→</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span><span class="main">}</span><span>"</span>
  <span class="keyword1 command">proof</span>
    <span class="keyword3 command">fix</span> <span class="skolem">A</span>
    <span class="keyword3 command">assume</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">A</span> <span class="main">∈</span> <span class="main">[</span></span>elts</span> <span class="free">α</span><span>]⇗</span><span class="numeral">2</span><span>⇖</span><span>"</span>
    <span class="keyword1 command">then</span> <span class="keyword3 command">obtain</span> <span class="skolem skolem">x</span> <span class="skolem skolem">y</span> <span class="keyword2 keyword">where</span> xy<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">x</span> <span class="main">∈</span> elts</span> <span class="free">α</span><span>"</span></span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">y</span> <span class="main">∈</span> elts</span> <span class="free">α</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span><span>"</span></span> <span class="keyword2 keyword">and</span> A<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">A</span> <span class="main">=</span> <span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">}</span><span>"</span></span>
      <span class="keyword1 command improper command">apply</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> nsets_2_eq<span class="main">)</span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Ord_in_Ord Ord_linear_lt assms insert_commute<span class="main">)</span>
    <span class="keyword1 command">consider</span> <span class="quoted quoted"><span>"</span><span class="skolem">π</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">π</span> <span class="skolem">y</span><span>"</span></span> <span class="main">|</span> <span class="quoted quoted"><span>"</span><span class="skolem">π</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">π</span> <span class="skolem">x</span><span>"</span></span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Ordπ Ord_linear_lt injπ inj_onD less_imp_not_eq2 xy<span class="main">)</span>
    <span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span><span class="skolem">f</span> <span class="skolem">A</span> <span class="main">∈</span> <span class="main">{..&lt;</span>Suc <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span><span class="main">}</span><span>"</span></span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> A One_nat_def lessI lessThan_iff zero_less_Suc <span class="quoted quoted"><span>‹</span><span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span><span>›</span></span> A exE_some <span class="main main">[</span><span class="operator">OF</span> _ f_def<span class="main main">]</span><span class="main">)</span>
  <span class="keyword1 command">qed</span>
</pre>

<pre class="source">
  <span class="keyword1 command">have</span> <span class="quoted">False</span>
    <span class="keyword2 keyword">if</span> eq<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>tp</span> <span class="skolem">H</span> <span class="main">=</span> succ</span> <span class="main">(</span>vcard <span class="free">α</span><span class="main">)</span><span>"</span> <span class="keyword2 keyword">and</span> H<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">H</span> <span class="main">⊆</span> elts</span> <span class="free">α</span><span>"</span></span>
    <span class="keyword2 keyword">and</span> 0<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">⋀</span><span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∈</span> <span class="main">[</span></span><span class="skolem">H</span><span>]⇗</span><span class="numeral">2</span><span>⇖ </span><span class="main">⟹</span> <span class="skolem">f</span> <span class="bound">A</span> <span class="main">=</span> <span class="main">0</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">H</span>
  <span class="keyword1 command">proof</span> <span class="operator">-</span>
    <span class="keyword1 command">have</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>small</span> <span class="skolem">H</span><span>"</span></span>
      <span class="keyword1 command">using</span> H down <span class="keyword1 command">by</span> <span class="operator">auto</span>
    <span class="keyword1 command">have</span> OH<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>Ord</span> <span class="skolem">x</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">H</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">x</span>
      <span class="keyword1 command">using</span> H Ord_in_Ord <span class="quoted"><span class="quoted"><span>‹</span>Ord</span> <span class="free">α</span><span>›</span></span> that <span class="keyword1 command">by</span> <span class="operator">blast</span>
    <span class="keyword1 command">have</span> π<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">π</span> <span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">π</span> <span class="skolem">y</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">x</span><span class="main">∈</span><span class="skolem">H</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">y</span><span class="main">∈</span><span class="skolem">H</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">x</span><span class="main">&lt;</span><span class="skolem">y</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1 command">using</span> 0 <span class="main">[</span><span class="operator">of</span> <span class="quoted quoted"><span>"</span><span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">}</span><span>"</span></span><span class="main">]</span> that H fiff <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> nsets_2_eq<span class="main">)</span>
    <span class="keyword1 command">have</span> sub_vcard<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">π</span> <span class="main">`</span> <span class="skolem">H</span> <span class="main">⊆</span> elts</span> <span class="main">(</span>vcard</span> <span class="free">α</span><span class="main">)</span><span>"</span>
      <span class="keyword1 command">using</span> H funπ <span class="keyword1 command">by</span> <span class="operator">auto</span>
    <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span>tp</span> <span class="skolem">H</span> <span class="main">=</span> tp</span> <span class="main">(</span><span class="skolem">π</span> <span class="main">`</span> <span class="skolem">H</span><span class="main">)</span><span>"</span>
    <span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">rule</span> ordertype_VWF_inc_eq <span class="main main">[</span><span class="operator">symmetric</span><span class="main main">]</span><span class="main">)</span>
      <span class="keyword3 command">show</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">π</span> <span class="main">`</span> <span class="skolem">H</span> <span class="main">⊆</span> ON</span><span>"</span></span>
      <span class="keyword1 command">using</span> H Ordπ <span class="keyword1 command">by</span> <span class="operator">blast</span>
    <span class="keyword1 command">qed</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> π OH subsetI<span class="main">)</span>
    <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">…</span> <span class="main">≤</span> vcard</span> <span class="free">α</span><span>"</span></span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> H sub_vcard assms ordertype_le_Ord<span class="main">)</span>
    <span class="keyword1 command">finally</span> <span class="keyword3 command">show</span> <span class="quoted">False</span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> eq succ_le_iff<span class="main">)</span>
  <span class="keyword1 command">qed</span>
</pre>

<pre class="source">
  <span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted">False</span>
    <span class="keyword2 keyword">if</span> eq<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>tp</span> <span class="skolem">H</span> <span class="main">=</span> ω</span><span>"</span> <span class="keyword2 keyword">and</span> H<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">H</span> <span class="main">⊆</span> elts</span> <span class="free">α</span><span>"</span></span>
      <span class="keyword2 keyword">and</span> 1<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">⋀</span><span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main">∈</span> <span class="main">[</span></span><span class="skolem">H</span><span>]⇗</span><span class="numeral">2</span><span>⇖ </span><span class="main">⟹</span> <span class="skolem">f</span> <span class="bound">A</span> <span class="main">=</span> Suc <span class="main">0</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">H</span>
  <span class="keyword1 command">proof</span> <span class="operator">-</span>
    <span class="keyword1 command">have</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>small</span> <span class="skolem">H</span><span>"</span></span>
      <span class="keyword1 command">using</span> H down <span class="keyword1 command">by</span> <span class="operator">auto</span>
    <span class="keyword3 command">define</span> <span class="skolem skolem">η</span> <span class="keyword2 keyword">where</span> <span class="quoted"><span class="quoted"><span>"</span><span class="skolem">η</span> <span class="main">≡</span> inv_into <span class="skolem">H</span> <span class="main">(</span>ordermap</span> <span class="skolem">H</span> VWF</span><span class="main">)</span> <span class="main">∘</span> ord_of_nat<span>"</span>
    <span class="keyword1 command">have</span> bij<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>bij_betw <span class="main">(</span>ordermap</span> <span class="skolem">H</span> VWF</span><span class="main">)</span> <span class="skolem">H</span> <span class="main">(</span>elts ω<span class="main">)</span><span>"</span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> ordermap_bij <span class="quoted"><span class="quoted"><span>‹</span>small</span> <span class="skolem">H</span><span>›</span></span> eq total_on_VWF wf_VWF<span class="main">)</span>
    <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span>bij_betw <span class="main">(</span>inv_into <span class="skolem">H</span> <span class="main">(</span>ordermap</span> <span class="skolem">H</span> VWF</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>elts ω<span class="main">)</span> <span class="skolem">H</span><span>"</span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> bij_betw_inv_into<span class="main">)</span>
    <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> η<span class="main">:</span> <span class="quoted quoted"><span>"</span>bij_betw <span class="skolem">η</span> UNIV <span class="skolem">H</span><span>"</span></span>
      <span class="keyword1 command">unfolding</span> η_def
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> ω_def bij_betw_comp_iff2 bij_betw_def elts_of_set inf inj_ord_of_nat order_refl<span class="main">)</span>
    <span class="keyword1 command">have</span> Ordη<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span>Ord</span> <span class="main">(</span><span class="skolem">η</span> <span class="skolem">k</span><span class="main">)</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">k</span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">meson</span> H Ord_in_Ord UNIV_I η assms bij_betw_apply subsetD<span class="main">)</span>
    <span class="keyword3 command">obtain</span> <span class="skolem skolem">k</span> <span class="keyword2 keyword">where</span> k<span class="main">:</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">(</span><span class="main">(</span><span class="skolem">π</span> <span class="main">∘</span> <span class="skolem">η</span><span class="main">)</span><span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="skolem">π</span> <span class="main">∘</span> <span class="skolem">η</span><span class="main">)</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">∉</span> VWF</span><span>"</span></span>
      <span class="keyword1 command">using</span> wf_VWF wf_iff_no_infinite_down_chain <span class="keyword1 command">by</span> <span class="operator">blast</span>
    <span class="keyword1 command">have</span> π<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">π</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">π</span> <span class="skolem">x</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">x</span><span class="main">∈</span><span class="skolem">H</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">y</span><span class="main">∈</span><span class="skolem">H</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">x</span><span class="main">&lt;</span><span class="skolem">y</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">x</span> <span class="skolem">y</span>
      <span class="keyword1 command">using</span> 1 <span class="main">[</span><span class="operator">of</span> <span class="quoted quoted"><span>"</span><span class="main">{</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">}</span><span>"</span></span><span class="main">]</span> that H fiff <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> nsets_2_eq<span class="main">)</span>
    <span class="keyword1 command">have</span> <span class="quoted">False</span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">η</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">≤</span> <span class="skolem">η</span> <span class="skolem">k</span><span>"</span></span>
    <span class="keyword1 command">proof</span> <span class="operator">-</span>
      <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span><span class="main">(</span><span class="skolem">η</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span><span class="main">,</span> <span class="skolem">η</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">∈</span> VWF</span> <span class="main">∨</span> <span class="skolem">η</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">η</span> <span class="skolem">k</span><span>"</span></span>
        <span class="keyword1 command">using</span> that Ordη Ord_mem_iff_lt <span class="keyword1 command">by</span> <span class="operator">auto</span>
      <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span>ordermap</span> <span class="skolem">H</span> VWF</span> <span class="main">(</span><span class="skolem">η</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> ordermap <span class="skolem">H</span> VWF <span class="main">(</span><span class="skolem">η</span> <span class="skolem">k</span><span class="main">)</span><span>"</span>
        <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> η <span class="quoted"><span class="quoted"><span>‹</span>small</span> <span class="skolem">H</span><span>›</span></span> bij_betw_imp_surj_on ordermap_mono_le rangeI trans_VWF wf_VWF<span class="main">)</span>
      <span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span>ordermap</span> <span class="skolem">H</span> VWF</span> <span class="main">(</span><span class="skolem">η</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> succ <span class="main">(</span>ord_of_nat <span class="skolem">k</span><span class="main">)</span><span>"</span>
        <span class="keyword1 command">unfolding</span> η_def <span class="keyword1 command">using</span> bij bij_betw_inv_into_right <span class="keyword1 command">by</span> <span class="operator">force</span>
      <span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span>ordermap</span> <span class="skolem">H</span> VWF</span> <span class="main">(</span><span class="skolem">η</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">=</span> ord_of_nat <span class="skolem">k</span><span>"</span>
        <span class="keyword1 command improper command">apply</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> η_def<span class="main">)</span>
        <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">meson</span> bij bij_betw_inv_into_right ord_of_nat_ω<span class="main">)</span>
      <span class="keyword1 command">ultimately</span> <span class="keyword1 command">have</span> <span class="quoted"><span class="quoted"><span>"</span>succ</span> <span class="main">(</span>ord_of_nat</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">≤</span> ord_of_nat <span class="skolem">k</span><span>"</span>
        <span class="keyword1 command">by</span> <span class="operator">simp</span>
      <span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="quoted">False</span>
        <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> less_eq_V_def<span class="main">)</span>
    <span class="keyword1 command">qed</span>
    <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="skolem">η</span> <span class="skolem">k</span> <span class="main">&lt;</span> <span class="skolem">η</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span><span>"</span></span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Ordη Ord_linear_lt dual_order.strict_implies_order eq_refl<span class="main">)</span>
    <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="skolem">π</span> <span class="main">∘</span> <span class="skolem">η</span><span class="main">)</span><span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">(</span><span class="skolem">π</span> <span class="main">∘</span> <span class="skolem">η</span><span class="main">)</span><span class="skolem">k</span><span>"</span></span>
      <span class="keyword1 command">using</span> π η bij_betw_apply <span class="keyword1 command">by</span> <span class="operator">force</span>
    <span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="quoted">False</span>
      <span class="keyword1 command">using</span> k
      <span class="keyword1 command improper command">apply</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> subset_iff<span class="main">)</span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> H Ordπ UNIV_I VWF_iff_Ord_less η bij_betw_imp_surj_on image_subset_iff<span class="main">)</span>
  <span class="keyword1 command">qed</span>
</pre>

<pre class="source">
  <span class="keyword1 command">ultimately</span> <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span>
    <span class="keyword1 command improper command">apply</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> partn_lst_def image_subset_iff<span class="main">)</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> f_Pi less_2_cases nth_Cons_0 nth_Cons_Suc numeral_2_eq_2<span class="main">)</span>
<span class="keyword1 command">qed</span>
</pre>

<pre class="source">
</pre>

<pre class="source">
</pre>

<pre class="source">
</pre>

<pre class="source">
</pre>

<pre class="source">
</pre>

<pre class="source">
</pre>


