---
layout: post
title:  "Introductory example: Fibonacci numbers"
usemathjax: true 
tags: examples, Isabelle, Fibonacci
---

Let's see what mathematics looks like in Isabelle/HOL.  This post is not a self-contained tutorial; it simply aims to show a simple recursive definition and a couple of proofs by induction. Some good (and bad) points about machine proof should become obvious. There are links to further reading at the end.

So here is the definition of the Fibonacci function:

<pre class="source">
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">fib</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">â‡’</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">fib</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">fib</span> <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">fib</span> <span class="main">(</span>Suc <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">fib</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> <span class="free">fib</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
</pre>

This looks familiar enough except for the successor function, `Suc`, which is part of the definition of the natural numbers. Ugly perhaps but easy enough to get used to. The successor of $n$ is simply $n+1$.

Facts about *fib* are typically proved by induction, and most of us know to match the induction principle to the form of the recursion: with two base cases (for 0 and 1) and an induction step that has induction hypotheses for each of the two recursive calls. We begin with a trivial example:

<pre class="source">
<span class="keyword1"><span class="command">lemma</span></span> fib_positive<span class="main">:</span> <span class="quoted"><span class="quoted">"fib <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fib.induct<span class="main">)</span> <span class="operator">auto</span>
</pre>

The proof of `fib_positive` is by induction (a version tailored to *fib* as outlined above) followed by general automation. It's trivial and nobody should want to see more of the proof. But the next example is a distinctly nontrivial identity:

<pre class="source">
<span class="keyword1"><span class="command">lemma</span></span> fib_add<span class="main">:</span> <span class="quoted"><span class="quoted">"fib <span class="main">(</span>Suc <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fib <span class="main">(</span>Suc <span class="free">k</span><span class="main">)</span> <span class="main">*</span> fib <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">+</span> fib <span class="free">k</span> <span class="main">*</span> fib <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fib.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distrib_left<span class="main">)</span>
</pre>

The machine proof resembles the previous one except for a reference (`distrib_left`) to a distributive law, but the logical reasoning generated by `auto` is completely different. The calculation is complicated enough to be written out in any text, yet Isabelle's built-in automation doesn't need any hints: it proves a statement that is genuinely nonobvious. This will not always be the case!

The next example is different again, a claim that is plausible without an obvious proof. Here we need to flesh out the proof, with an explicit reference to the third case (the induction step):

<pre class="source">
<span class="keyword1"><span class="command">lemma</span></span> coprime_fib_Suc<span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="main">(</span>fib <span class="free">n</span><span class="main">)</span> <span class="main">(</span>fib <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> fib.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> coprime_iff_gcd_eq_1 fib.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> gcd.commute gcd_add1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
</pre>

This undoubtedly cryptic code already tells us what formal proofs can look like. We can see that it's an induction and that the third case has been singled out for special treatment. The list of identifiers in the penultimate line are the names of known facts used to prove the induction step. The base cases are proved automatically (`qed auto`). Even the induction step was proved automatically. Isabelle has a subsystem, [sledgehammer](https://isabelle.in.tum.de/dist/doc/sledgehammer.pdf), that can analyse a statement to be proved and actually generate Isabelle proof text to prove it. The penultimate line, which contains the heart of the proof, was given to us for free. Sledgehammer can be called using a single mouse click.

To run this example yourself, you need to install [Isabelle](https://isabelle.in.tum.de/) (it's easy!) and perhaps read some [introductory documentation](https://isabelle.in.tum.de/dist/Isabelle2021/doc/prog-prove.pdf). The file containing this example can be downloaded [here](/Isabelle-Examples/Fibonacci.thy).
