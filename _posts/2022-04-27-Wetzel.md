---
layout: post
title:  "Wetzel's problem and the continuum hypothesis"
usemathjax: true
tags: [ZFC_in_HOL, Paul Erdős, set theory, Proofs from THE BOOK, David Hilbert, formalised mathematics]
---

The [continuum hypothesis](https://plato.stanford.edu/entries/continuum-hypothesis/) (CH) dates from the 19th century and became the first of David [Hilbert's famous unsolved problems](https://en.wikipedia.org/wiki/Hilbert%27s_problems). Gödel proved it to be consistent with the axioms of set theory (ZFC), while Cohen exhibited models of ZFC in which CH failed. New axioms would be needed to settle the question. Despite decades of intensive research, the status of CH [remains open](https://www.quantamagazine.org/how-many-numbers-exist-infinity-proof-moves-math-closer-to-an-answer-20210715/).
However recondite it may be, CH cannot be ignored: ordinary-looking mathematical questions occasionally bump into it.

### What is the continuum hypothesis anyway?

CH can be expressed by the mysterious formula $2^{\aleph_0}=\aleph_1$, and yet it is a simple question. A set is *countable* if its elements can be written in a series. (So finite sets are also countable.) The concept of countability was readily accepted by 19th century mathematicians, who by assuming facts such as "a countable union of countable sets is countable" found themselves depending on the [axiom of choice](https://plato.stanford.edu/entries/axiom-choice/) (AC) before it had even been promulgated.

[Cantor](https://en.wikipedia.org/wiki/Georg_Cantor) had proved that the algebraic numbers were countable and that the real numbers were not.
He proved that the finite interval $[0,1]$ could be put into bijection with any $\mathbb{R}^n$, and called this "cardinality of the continuum" $\frak{c}$.
He then asked whether some intermediate set $X$ of real numbers existed, itself uncountable but of smaller cardinality than $\mathbb{R}$.
And that simply depended on the existence (or not) of a bijection between $X$ and $\mathbb{R}$:
it need not involve the cardinal numbers or AC.

### The story of Wetzel's problem

I first learned of Wetzel's problem from [*Proofs from THE BOOK*](https://link.springer.com/book/10.1007/978-3-662-57265-8) by Aigner and Ziegler, a compendium of beautiful proofs, many somehow connected with the legendary Hungarian mathematician, Paul Erdős. It involves some complex analysis, fortunately only a tiny bit, because that's all I know myself. Wetzel asked

> If $\\{f_\alpha\\}$ is a family of distinct [analytic functions](https://en.wikipedia.org/wiki/Analytic_function) (on some fixed domain) such that for each $z$ the set of values $\\{f_\alpha(z)\\}$ is countable, is the family itself countable?

Erdős stumbled upon this question in a problem book and in 1964 [published a solution](https://projecteuclid.org/journals/michigan-mathematical-journal/volume-11/issue-1/An-interpolation-problem-associated-with-the-continuum-hypothesis/10.1307/mmj/1028999028.full): Wetzel's question is equivalent to the negation of CH. It is therefore independent of the generally accepted axioms of set theory!

Erdős first assumes ¬CH. He then shows that for any family of analytic functions $\\{f_\alpha\\}$ of size $\aleph_1$ there exists a complex number $z$ such that all $\aleph_1$ values $\\{f_\alpha(z)\\}$ are distinct and therefore this set is uncountable.
If on the other hand CH holds, Erdős shows how, by transfinite induction, one can construct a family $\\{f_\alpha\\}$ of cardinality $\aleph_1$ such that $\\{f_\alpha(z)\\}$ is countable for all $z$.

Garcia and Shoemaker have written a brief [history of the problem](https://arxiv.org/abs/1406.5085) and its origins.

### Wetzel's problem in Isabelle/HOL

Let's begin by defining the predicate `Wetzel` on sets of complex-valued functions. It holds if every element of the given set $F$ is analytic on the complex plane and if every set of the form $\\{f(z) \mid f\in F\\}$  (for any $z$) is countable.

<pre class="source">
<span class="keyword1 command">definition</span> <span class="entity">Wetzel</span> <span class="main">::</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>complex <span class="main">⇒</span> complex<span class="main">)</span> set <span class="main">⇒</span> bool<span>"</span></span><span>
  </span><span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="free">Wetzel</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">F</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">f</span><span class="main">∈</span><span class="bound">F</span><span class="main">.</span> <span class="bound">f</span> <span class="keyword1">analytic_on</span> UNIV<span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">z</span><span class="main">.</span> countable<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">z</span><span class="main">)</span> <span class="main">`</span> <span class="bound">F</span><span class="main">)</span><span class="main">)</span><span>"</span></span>
</pre>

Because the proof refers to ordinals, cardinals and transfinite induction, it's natural to base it on the theory of ZFC_in_HOL, which was described in a [previous post]({% post_url 2022-04-06-ZFC_in_HOL %}).
The easier case is when ¬CH, i.e., when $\aleph_0 < \aleph_1 < 2^{\aleph_0}=\frak{c}$.
The formal proof is compact enough to insert in full, and it's legible enough to reveal the main proof ideas.
It begins with a lemma to exhibit some $z_0$ such that the cardinality of $\\{f(z_0) \mid f\in F\\}$  is at least $\aleph_1$, under the assumption that $F$ is uncountable. Skipping down to the very bottom of the proof, we see that the result quickly follows from this lemma and the Wetzel assumption.

Now for the proof of the lemma. We are given that $F$ is uncountable, which guarantees the existence of some $F' \subseteq F$ having cardinality $\aleph_1$, from which we obtain a bijection $\phi$ between the ordinals below $\aleph_1$ and $F'$.
Now for ordinals $\alpha$, $\beta < \omega_1$ we define $S\alpha\beta = \\{z. \phi\alpha z = \phi\beta z\\}$. (Note: $\omega_1$ is nothing but $\aleph_1$, regarded as an ordinal.)
Lemma `co_S` tells us that $S\alpha\beta$ is countable if $\alpha<\beta$. Its proof relies on the fact `holomorphic_countable_equal_UNIV`: since $\phi\alpha$ and $\phi\beta$ must be different functions, and they are holomorphic, they can agree on only countably many points. (And that's the sum total of the complex analysis required here.)
Next, we define $SS = \bigcup_{\alpha<\beta<\aleph_1}\, S\alpha\beta$.
It takes a dozen lines of calculations to show $|SS|\leq \aleph_1$.
By ¬CH we have $\aleph_1 < \frak{c}$ and trivially obtain some complex number $z_0\not\in SS$.
By the definition of $SS$, since $\phi\alpha z_0 \not= \phi\beta z_0$ for all $\alpha<\beta<\omega_1$,
we find that $|\\{f(z_0) \mid f\in F'\\}| = \aleph_1$, from which the lemma follows.

<pre class="source">
<span class="keyword1 command">proposition</span> Erdos_Wetzel_nonCH<span class="main">:</span><span>
  </span><span class="keyword2 keyword">assumes</span> W<span class="main">:</span> <span class="quoted quoted"><span>"</span>Wetzel <span class="free">F</span><span>"</span></span> <span class="keyword2 keyword">and</span> NCH<span class="main">:</span> <span class="quoted quoted"><span>"</span>C_continuum <span class="main">&gt;</span> <span class="main">ℵ</span><span class="main">1</span><span>"</span></span> <span class="keyword2 keyword">and</span> <span class="quoted quoted"><span>"</span>small <span class="free">F</span><span>"</span></span><span>
  </span><span class="keyword2 keyword">shows</span> <span class="quoted quoted"><span>"</span>countable <span class="free">F</span><span>"</span></span><span>
</span><span class="keyword1 command">proof</span> <span class="operator">-</span><span>
  </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">∃</span><span class="bound">z0</span><span class="main">.</span> gcard <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">z0</span><span class="main">)</span> <span class="main">`</span> <span class="free">F</span><span class="main">)</span> <span class="main">≥</span> <span class="main">ℵ</span><span class="main">1</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span>uncountable <span class="free">F</span><span>"</span></span><span>
  </span><span class="keyword1 command">proof</span> <span class="operator">-</span><span>
    </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>gcard <span class="free">F</span> <span class="main">≥</span> <span class="main">ℵ</span><span class="main">1</span><span>"</span></span><span>
      </span><span class="keyword1 command">using</span> <span class="quoted quoted"><span>‹</span>small <span class="free">F</span><span>›</span></span> that uncountable_gcard_ge <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
    </span><span class="keyword1 command">then</span> <span class="keyword3 command">obtain</span> <span class="skolem skolem">F'</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">F'</span> <span class="main">⊆</span> <span class="free">F</span><span>"</span></span> <span class="keyword2 keyword">and</span> F'<span class="main">:</span> <span class="quoted quoted"><span>"</span>gcard <span class="skolem">F'</span> <span class="main">=</span> <span class="main">ℵ</span><span class="main">1</span><span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">meson</span> Card_Aleph Ord_1 subset_smaller_gcard <span class="quoted quoted"><span>‹</span>small <span class="free">F</span><span>›</span></span><span class="main">)</span><span>
    </span><span class="keyword1 command">then</span> <span class="keyword3 command">obtain</span> <span class="skolem skolem">φ</span> <span class="keyword2 keyword">where</span> φ<span class="main">:</span> <span class="quoted quoted"><span>"</span>bij_betw <span class="skolem">φ</span> <span class="main">(</span>elts ω1<span class="main">)</span> <span class="skolem">F'</span><span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> TC_small eqpoll_def gcard_eqpoll<span class="main">)</span><span>
    </span><span class="keyword3 command">define</span> <span class="skolem skolem">S</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">S</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">α</span> <span class="bound">β</span><span class="main">.</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="skolem">φ</span> <span class="bound">α</span> <span class="bound">z</span> <span class="main">=</span> <span class="skolem">φ</span> <span class="bound">β</span> <span class="bound">z</span><span class="main">}</span><span>"</span></span><span>
    </span><span class="keyword1 command">have</span> co_S<span class="main">:</span> <span class="quoted quoted"><span>"</span>gcard <span class="main">(</span><span class="skolem">S</span> <span class="skolem">α</span> <span class="skolem">β</span><span class="main">)</span> <span class="main">≤</span> <span class="main">ℵ</span><span class="main">0</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">α</span> <span class="main">∈</span> elts <span class="skolem">β</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">β</span> <span class="main">∈</span> elts ω1<span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">α</span> <span class="skolem">β</span><span>
    </span><span class="keyword1 command">proof</span> <span class="operator">-</span><span>
      </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="skolem">φ</span> <span class="skolem">α</span> <span class="keyword1">holomorphic_on</span> UNIV<span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">φ</span> <span class="skolem">β</span> <span class="keyword1">holomorphic_on</span> UNIV<span>"</span></span><span>
        </span><span class="keyword1 command">using</span> W <span class="quoted quoted"><span>‹</span><span class="skolem">F'</span> <span class="main">⊆</span> <span class="free">F</span><span>›</span></span> <span class="keyword1 command">unfolding</span> Wetzel_def<span>
        </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">meson</span> Ord_ω1 Ord_trans φ analytic_imp_holomorphic bij_betwE subsetD that<span class="main">)</span><span class="main keyword3">+</span><span>
      </span><span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="skolem">φ</span> <span class="skolem">α</span> <span class="main">≠</span> <span class="skolem">φ</span> <span class="skolem">β</span><span>"</span></span><span>
        </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Ord_ω1 Ord_in_Ord Ord_trans OrdmemD φ bij_betw_imp_inj_on inj_on_def less_V_def that<span class="main">)</span><span>
      </span><span class="keyword1 command">ultimately</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>countable <span class="main">(</span><span class="skolem">S</span> <span class="skolem">α</span> <span class="skolem">β</span><span class="main">)</span><span>"</span></span><span>
        </span><span class="keyword1 command">using</span> holomorphic_countable_equal_UNIV <span class="keyword1 command">unfolding</span> S_def <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
      </span><span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span><span>
        </span><span class="keyword1 command">using</span> countable_imp_g_le_Aleph0 <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
    </span><span class="keyword1 command">qed</span><span>
    </span><span class="keyword3 command">define</span> <span class="skolem skolem">SS</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">SS</span> <span class="main">≡</span> <span class="main">⨆</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">β</span><span class="main">.</span> <span class="main">⨆</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">α</span><span class="main">.</span> <span class="skolem">S</span> <span class="bound">α</span> <span class="bound">β</span><span class="main">)</span> <span class="main">`</span> elts <span class="bound">β</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span>  elts<span class="main">(</span><span class="main">ℵ</span><span class="main">1</span><span class="main">)</span><span class="main">)</span><span>"</span></span><span>
    </span><span class="keyword1 command">have</span> F'_eq<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">F'</span> <span class="main">=</span>  <span class="skolem">φ</span> <span class="main">`</span> elts ω1<span>"</span></span><span>
      </span><span class="keyword1 command">using</span> φ bij_betw_imp_surj_on <span class="keyword1 command">by</span> <span class="operator">auto</span><span>
    </span><span class="keyword1 command">have</span> §<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">⋀</span><span class="bound">β</span><span class="main">.</span> <span class="bound">β</span> <span class="main">∈</span> elts ω1 <span class="main">⟹</span> gcard <span class="main">(</span><span class="main">⋃</span><span class="bound">α</span><span class="main">∈</span>elts <span class="bound">β</span><span class="main">.</span> <span class="skolem">S</span> <span class="bound">α</span> <span class="bound">β</span><span class="main">)</span> <span class="main">≤</span> ω<span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Aleph_0 TC_small co_S countable_UN countable_iff_g_le_Aleph0 less_ω1_imp_countable<span class="main">)</span><span>
    </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>gcard <span class="skolem">SS</span> <span class="main">≤</span> gcard <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">β</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">α</span><span class="main">∈</span>elts <span class="bound">β</span><span class="main">.</span> <span class="skolem">S</span> <span class="bound">α</span> <span class="bound">β</span><span class="main">)</span> <span class="main">`</span> elts ω1<span class="main">)</span> <span class="main">⊗</span> <span class="main">ℵ</span><span class="main">0</span><span>"</span></span><span>
      </span><span class="keyword1 command improper command">apply</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> SS_def<span class="main">)</span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> <span class="main main">(</span>no_types<span class="main main">,</span> lifting<span class="main main">)</span> <span class="quoted"><span>"</span>§<span>"</span></span> TC_small gcard_Union_le_cmult imageE<span class="main">)</span><span>
    </span><span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">…</span>  <span class="main">≤</span> <span class="main">ℵ</span><span class="main">1</span><span>"</span></span><span>
    </span><span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">rule</span> cmult_InfCard_le<span class="main">)</span><span>
      </span><span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span>gcard <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">β</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">α</span><span class="main">∈</span>elts <span class="bound">β</span><span class="main">.</span> <span class="skolem">S</span> <span class="bound">α</span> <span class="bound">β</span><span class="main">)</span> <span class="main">`</span> elts ω1<span class="main">)</span> <span class="main">≤</span> ω1<span>"</span></span><span>
        </span><span class="keyword1 command">using</span> gcard_image_le <span class="keyword1 command">by</span> <span class="operator">fastforce</span><span>
    </span><span class="keyword1 command">qed</span> <span class="operator">auto</span><span>
    </span><span class="keyword1 command">finally</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>gcard <span class="skolem">SS</span> <span class="main">≤</span> <span class="main">ℵ</span><span class="main">1</span><span>"</span></span> <span class="keyword1 command">.</span><span>
    </span><span class="keyword1 command">with</span> NCH <span class="keyword3 command">obtain</span> <span class="skolem skolem">z0</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">z0</span> <span class="main">∉</span> <span class="skolem">SS</span><span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Complex_gcard UNIV_eq_I less_le_not_le<span class="main">)</span><span>
    </span><span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>inj_on <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">φ</span> <span class="bound">x</span> <span class="skolem">z0</span><span class="main">)</span> <span class="main">(</span>elts ω1<span class="main">)</span><span>"</span></span><span>
      </span><span class="keyword1 command improper command">apply</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> SS_def S_def inj_on_def<span class="main">)</span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Ord_ω1 Ord_in_Ord Ord_linear<span class="main">)</span><span>
    </span><span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>gcard <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="skolem">z0</span><span class="main">)</span> <span class="main">`</span> <span class="skolem">F'</span><span class="main">)</span> <span class="main">=</span> <span class="main">ℵ</span><span class="main">1</span><span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">)</span> F' F'_eq gcard_image imageE inj_on_def<span class="main">)</span><span>
    </span><span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> TC_small <span class="quoted quoted"><span>‹</span><span class="skolem">F'</span> <span class="main">⊆</span> <span class="free">F</span><span>›</span></span> image_mono subset_imp_gcard_le<span class="main">)</span><span>
  </span><span class="keyword1 command">qed</span><span>
  </span><span class="keyword1 command">with</span> W <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span><span>
    </span><span class="keyword1 command">unfolding</span> Wetzel_def <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">meson</span> countable uncountable_gcard_ge<span class="main">)</span><span>
</span><span class="keyword1 command">qed</span>
</pre>


### Wetzel's problem, assuming the continuum hypothesis

The case when the continuum hypothesis holds is much more difficult, even setting aside the hardest part of the proof. We must construct an uncountable family of analytic functions that makes the `Wetzel` property fail.

<pre class="source">
<span class="keyword1 command">proposition</span> Erdos_Wetzel_CH<span class="main">:</span><span>
  </span><span class="keyword2 keyword">assumes</span> CH<span class="main">:</span> <span class="quoted quoted"><span>"</span>C_continuum <span class="main">=</span> <span class="main">ℵ</span><span class="main">1</span><span>"</span></span><span>
  </span><span class="keyword2 keyword">obtains</span> <span class="free">F</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span>Wetzel <span class="free">F</span><span>"</span></span> <span class="keyword2 keyword">and</span> <span class="quoted quoted"><span>"</span>uncountable <span class="free">F</span><span>"</span></span>
</pre>


Consider the set $D\subseteq\mathbb{C}$ of "rational" complex numbers, i.e.
$$
\begin{align*}
 D = \{p+iq\mid p,q\in\mathbb{Q}\}.
\end{align*}
$$
By CH we can write $\mathbb{C} = \\{z_\alpha : \alpha < \omega_1 \\}$ and it will suffice to construct
 $\\{f_\beta : \beta < \omega_1 \\}$ such that
$$
\begin{align*}
 f_\beta (z_\alpha) \in D
\end{align*}
$$
if $\alpha<\beta$.
Since the set $D$ is countable and the $z_\alpha$ for $\alpha < \omega_1$ include all complex numbers, the desired result follows.

The formal proof begins with a self-evident definition of $D$. It's easily shown to be countable, and with somewhat unexpected difficulty, infinite. That $D$ is dense in $\mathbb{C}$ requires an explicit proof that any complex $z$ can be approximated arbitrarily closely by some element $w$ of $D$. Note that
"<span class="main">closure <span class="skolem">D</span> <span class="main">=</span> UNIV</span>"
expresses that the closure of $D$ equals the universal set *of complex numbers*, i.e. the entire complex plane.


<pre class="source">
<span class="keyword1 command">proof</span> <span class="operator">-</span><span>
  </span><span class="keyword3 command">define</span> <span class="skolem skolem">D</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">D</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> Re <span class="bound">z</span> <span class="main">∈</span> <span class="main">ℚ</span> <span class="main">∧</span> Im <span class="bound">z</span> <span class="main">∈</span> <span class="main">ℚ</span><span class="main">}</span><span>"</span></span><span>
  </span><span class="keyword1 command">have</span> Deq<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">D</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="main">ℚ</span><span class="main">.</span> <span class="main">⋃</span><span class="bound">y</span><span class="main">∈</span><span class="main">ℚ</span><span class="main">.</span> <span class="main">{</span>Complex <span class="bound">x</span> <span class="bound">y</span><span class="main">}</span><span class="main">)</span><span>"</span></span><span>
    </span><span class="keyword1 command">using</span> complex.collapse <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> D_def<span class="main">)</span><span>
  </span><span class="keyword1 command">with</span> countable_rat <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>countable <span class="skolem">D</span><span>"</span></span><span>
    </span><span class="keyword1 command">by</span> <span class="operator">blast</span><span>
  </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>infinite <span class="skolem">D</span><span>"</span></span><span>
    </span><span class="keyword1 command">unfolding</span> Deq<span>
    </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">intro</span> infinite_disjoint_family_imp_infinite_UNION Rats_infinite<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> disjoint_family_on_def<span class="main">)</span><span>
  </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">∃</span><span class="bound">w</span><span class="main">.</span> Re <span class="bound">w</span> <span class="main">∈</span> <span class="main">ℚ</span> <span class="main">∧</span> Im <span class="bound">w</span> <span class="main">∈</span> <span class="main">ℚ</span> <span class="main">∧</span> norm <span class="main">(</span><span class="bound">w</span> <span class="main">-</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">e</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">e</span> <span class="main">&gt;</span> <span class="main">0</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">z</span> <span class="keyword2 keyword">and</span> <span class="skolem">e</span><span class="main">::</span><span class="quoted">real</span><span>
  </span><span class="keyword1 command">proof</span> <span class="operator">-</span><span>
    </span><span class="keyword3 command">obtain</span> <span class="skolem skolem">x</span> <span class="skolem skolem">y</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">x</span><span class="main">∈</span><span class="main">ℚ</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">y</span><span class="main">∈</span><span class="main">ℚ</span><span>"</span></span> <span class="keyword2 keyword">and</span> xy<span class="main">:</span> <span class="quoted quoted"><span>"</span>dist <span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">(</span>Re <span class="skolem">z</span><span class="main">,</span> Im <span class="skolem">z</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">e</span><span>"</span></span><span>
      </span><span class="keyword1 command">using</span> <span class="quoted quoted"><span>‹</span><span class="skolem">e</span> <span class="main">&gt;</span> <span class="main">0</span><span>›</span></span> Rats_closure_real2 <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> closure_approachable<span class="main">)</span><span>
    </span><span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>dist <span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">(</span>Re <span class="skolem">z</span><span class="main">,</span> Im <span class="skolem">z</span><span class="main">)</span> <span class="main">=</span> norm <span class="main">(</span>Complex <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">-</span> <span class="skolem">z</span><span class="main">)</span><span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> norm_complex_def norm_prod_def dist_norm<span class="main">)</span><span>
    </span><span class="keyword1 command">ultimately</span> <span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span><span class="main">∃</span><span class="bound">w</span><span class="main">.</span> Re <span class="bound">w</span> <span class="main">∈</span> <span class="main">ℚ</span> <span class="main">∧</span> Im <span class="bound">w</span> <span class="main">∈</span> <span class="main">ℚ</span> <span class="main">∧</span> norm <span class="main">(</span><span class="bound">w</span> <span class="main">-</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">&lt;</span> <span class="skolem">e</span><span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> complex.sel<span class="main">)</span><span>
  </span><span class="keyword1 command">qed</span><span>
  </span><span class="keyword1 command">then</span> <span class="keyword1 command">have</span> cloD<span class="main">:</span> <span class="quoted quoted"><span>"</span>closure <span class="skolem">D</span> <span class="main">=</span> UNIV<span>"</span></span><span>
    </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> D_def closure_approachable dist_complex_def<span class="main">)</span>
</pre>

 In the formal proof, the transfinite enumeration $\\{\zeta_\alpha : \alpha < \omega_1 \\}$ of the complex plane is called $\zeta$. Next come some technical definitions: `inD` for functions whose range for certain arguments lies within $D$ and $\Phi$ for further constraints on the family `f` of analytic functions being defined transfinitely.


<pre class="source">
  <span class="keyword3 command">obtain</span> <span class="skolem skolem">ζ</span> <span class="keyword2 keyword">where</span> ζ<span class="main">:</span> <span class="quoted quoted"><span>"</span>bij_betw <span class="skolem">ζ</span> <span class="main">(</span>elts ω1<span class="main">)</span> <span class="main">(</span>UNIV<span class="main">::</span>complex set<span class="main">)</span><span>"</span></span><span>
    </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Complex_gcard TC_small assms eqpoll_def gcard_eqpoll<span class="main">)</span><span>
  </span><span class="keyword3 command">define</span> <span class="skolem skolem">inD</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">inD</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">β</span> <span class="bound">f</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">α</span> <span class="main">∈</span> elts <span class="bound">β</span><span class="main">.</span> <span class="bound">f</span> <span class="main">(</span><span class="skolem">ζ</span> <span class="bound">α</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">D</span><span class="main">)</span><span>"</span></span><span>
  </span><span class="keyword3 command">define</span> <span class="skolem skolem">Φ</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">Φ</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">β</span> <span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">β</span> <span class="keyword1">analytic_on</span> UNIV <span class="main">∧</span> <span class="skolem">inD</span> <span class="bound">β</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">β</span><span class="main">)</span> <span class="main">∧</span> inj_on <span class="bound">f</span> <span class="main">(</span>elts <span class="main">(</span>succ <span class="bound">β</span><span class="main">)</span><span class="main">)</span><span>"</span></span>
</pre>


The lemma called `*` will be the induction step, claiming the existence of the next member of the family, `h`, given that `f` is already defined below the ordinal $\gamma$.
 This ordinal is countable, but could be either finite or infinite. The finite case is easier, since the function we have to construct will simply be a polynomial, and trivially analytic. That is the case shown below, including induction on the finite ordinal $\gamma$. The infinite case requires serious trickery, so it has been elided. I hope one day to write a paper to explain the full details.


<pre class="source">
  <span class="keyword1 command">have</span> *<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">∃</span><span class="bound">h</span><span class="main">.</span> <span class="skolem">Φ</span> <span class="skolem">γ</span> <span class="main">(</span><span class="main">(</span>restrict <span class="skolem">f</span> <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="skolem">γ</span><span class="main">:=</span><span class="bound">h</span><span class="main">)</span><span class="main">)</span><span>"</span></span><span>
    </span><span class="keyword2 keyword">if</span> γ<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">γ</span> <span class="main">∈</span> elts ω1<span>"</span></span> <span class="keyword2 keyword">and</span> <span class="quoted quoted"><span>"</span><span class="main">∀</span><span class="bound">β</span> <span class="main">∈</span> elts <span class="skolem">γ</span><span class="main">.</span> <span class="skolem">Φ</span> <span class="bound">β</span> <span class="skolem">f</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">γ</span> <span class="skolem">f</span><span>
  </span><span class="keyword1 command">proof</span> <span class="operator">-</span><span>
    </span><span class="keyword1 command">have</span> f<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">∀</span><span class="bound">β</span> <span class="main">∈</span> elts <span class="skolem">γ</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">β</span> <span class="keyword1">analytic_on</span> UNIV <span class="main">∧</span> <span class="skolem">inD</span> <span class="bound">β</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">β</span><span class="main">)</span><span>"</span></span><span>
      </span><span class="keyword1 command">using</span> that <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> Φ_def<span class="main">)</span><span>
    </span><span class="keyword1 command">have</span> inj<span class="main">:</span> <span class="quoted quoted"><span>"</span>inj_on <span class="skolem">f</span> <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span>"</span></span><span>
      </span><span class="keyword1 command">using</span> that <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> Φ_def inj_on_def<span class="main">)</span> <span class="main">(</span><span class="operator">meson</span> Ord_ω1 Ord_in_Ord Ord_linear<span class="main">)</span><span>
    </span><span class="keyword3 command">obtain</span> <span class="skolem skolem">h</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">h</span> <span class="keyword1">analytic_on</span> UNIV<span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">inD</span> <span class="skolem">γ</span> <span class="skolem">h</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="main">∀</span><span class="bound">β</span> <span class="main">∈</span> elts <span class="skolem">γ</span><span class="main">.</span> <span class="skolem">h</span> <span class="main">≠</span> <span class="skolem">f</span> <span class="bound">β</span><span class="main">)</span><span>"</span></span><span>
    </span><span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted quoted"><span>"</span>finite <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span>"</span></span><span class="main">)</span><span>
      </span><span class="keyword3 command">case</span> True<span>
      </span><span class="keyword1 command">then</span> <span class="keyword3 command">obtain</span> <span class="skolem skolem">η</span> <span class="keyword2 keyword">where</span> η<span class="main">:</span> <span class="quoted quoted"><span>"</span>bij_betw <span class="skolem">η</span> <span class="main">{..&lt;</span>card <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span class="main">}</span> <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span>"</span></span><span>
        </span><span class="keyword1 command">using</span> bij_betw_from_nat_into_finite <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
      </span><span class="keyword3 command">define</span> <span class="skolem skolem">g</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">g</span> <span class="main">≡</span> <span class="skolem">f</span> <span class="keyword1">o</span> <span class="skolem">η</span><span>"</span></span><span>
      </span><span class="keyword3 command">define</span> <span class="skolem skolem">w</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">w</span> <span class="main">≡</span> <span class="skolem">ζ</span> <span class="keyword1">o</span> <span class="skolem">η</span><span>"</span></span><span>
      </span><span class="keyword1 command">have</span> gf<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">∀</span><span class="bound bound">i</span><span class="main">&lt;</span>card <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span class="main">.</span> <span class="skolem">h</span> <span class="main">≠</span> <span class="skolem">g</span> <span class="bound">i</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">β</span><span class="main">∈</span>elts <span class="skolem">γ</span><span class="main">.</span> <span class="skolem">h</span> <span class="main">≠</span> <span class="skolem">f</span> <span class="bound">β</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">h</span><span>
        </span><span class="keyword1 command">using</span> η <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> bij_betw_iff_bijections g_def<span class="main">)</span><span>
      </span><span class="keyword1 command">have</span> **<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">∃</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span> <span class="keyword1">analytic_on</span> UNIV <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound bound">i</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="bound">h</span> <span class="main">(</span><span class="skolem">w</span> <span class="bound">i</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">D</span> <span class="main">∧</span> <span class="bound">h</span> <span class="main">(</span><span class="skolem">w</span> <span class="bound">i</span><span class="main">)</span> <span class="main">≠</span> <span class="skolem">g</span> <span class="bound">i</span> <span class="main">(</span><span class="skolem">w</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span>"</span></span><span>
        </span><span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">n</span> <span class="main">≤</span> card <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">n</span><span>
        </span><span class="keyword1 command">using</span> that<span>
      </span><span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted skolem">n</span><span class="main">)</span><span>
        </span><span class="keyword3 command">case</span> 0<span>
        </span><span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="var quoted var">?case</span><span>
          </span><span class="keyword1 command">using</span> analytic_on_const <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
      </span><span class="keyword1 command">next</span><span>
        </span><span class="keyword3 command">case</span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span><span>
        </span><span class="keyword1 command">then</span> <span class="keyword3 command">obtain</span> <span class="skolem skolem">h</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">h</span> <span class="keyword1">analytic_on</span> UNIV<span>"</span></span> <span class="keyword2 keyword">and</span> hg<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">∀</span><span class="bound bound">i</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">w</span> <span class="bound">i</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">D</span> <span class="main">∧</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">w</span> <span class="bound">i</span><span class="main">)</span> <span class="main">≠</span> <span class="skolem">g</span> <span class="bound">i</span> <span class="main">(</span><span class="skolem">w</span> <span class="bound">i</span><span class="main">)</span><span>"</span></span><span>
          </span><span class="keyword1 command">using</span> Suc_leD <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
        </span><span class="keyword3 command">define</span> <span class="skolem skolem">p</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">p</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="main">∏</span><span class="bound">i</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="bound">z</span> <span class="main">-</span> <span class="skolem">w</span> <span class="bound">i</span><span>"</span></span><span>
        </span><span class="keyword1 command">have</span> p0<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">p</span> <span class="skolem">z</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound bound">i</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="skolem">z</span> <span class="main">=</span> <span class="skolem">w</span> <span class="bound">i</span><span class="main">)</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">z</span><span>
          </span><span class="keyword1 command">unfolding</span> p_def <span class="keyword1 command">by</span> <span class="operator">force</span><span>
        </span><span class="keyword3 command">obtain</span> <span class="skolem skolem">d</span> <span class="keyword2 keyword">where</span> d<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">d</span> <span class="main">∈</span> <span class="skolem">D</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">g</span> <span class="skolem">n</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">n</span><span class="main">)</span><span class="main">}</span><span>"</span></span><span>
          </span><span class="keyword1 command">using</span> <span class="quoted quoted"><span>‹</span>infinite <span class="skolem">D</span><span>›</span></span> <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> ex_in_conv finite.emptyI infinite_remove<span class="main">)</span><span>
        </span><span class="keyword3 command">define</span> <span class="skolem skolem">h'</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">h'</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="skolem">h</span> <span class="bound">z</span> <span class="main">+</span> <span class="skolem">p</span> <span class="bound">z</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">d</span> <span class="main">-</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">/</span> <span class="skolem">p</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">n</span><span class="main">)</span><span>"</span></span><span>
        </span><span class="keyword1 command">have</span> h'_eq<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">h'</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">h</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">i</span><span class="main">)</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">i</span><span class="main">&lt;</span><span class="skolem">n</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">i</span><span>
          </span><span class="keyword1 command">using</span> that <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> h'_def p0<span class="main">)</span><span>
        </span><span class="keyword3 command">show</span> <span class="var quoted var">?case</span><span>
        </span><span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">intro</span> exI strip conjI<span class="main">)</span><span>
          </span><span class="keyword1 command">have</span> nless<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">n</span> <span class="main">&lt;</span> card <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span>"</span></span><span>
            </span><span class="keyword1 command">using</span> Suc.prems Suc_le_eq <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
          </span><span class="keyword1 command">with</span> η <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="skolem">η</span> <span class="skolem">n</span> <span class="main">≠</span> <span class="skolem">η</span> <span class="skolem">i</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">i</span><span class="main">&lt;</span><span class="skolem">n</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">i</span><span>
            </span><span class="keyword1 command">using</span> that <span class="keyword1 command">unfolding</span> bij_betw_iff_bijections<span>
            </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> lessThan_iff less_not_refl order_less_trans<span class="main">)</span><span>
          </span><span class="keyword1 command">with</span> ζ η γ <span class="keyword1 command">have</span> pwn_nonzero<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">p</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span><span>"</span></span><span>
            </span><span class="keyword1 command improper command">apply</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> p0 w_def bij_betw_iff_bijections<span class="main">)</span><span>
            </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Ord_ω1 Ord_trans nless lessThan_iff order_less_trans<span class="main">)</span><span>
          </span><span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span><span class="skolem">h'</span> <span class="keyword1">analytic_on</span> UNIV<span>"</span></span><span>
            </span><span class="keyword1 command">unfolding</span> h'_def p_def <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic dynamic">analytic_intros</span> <span class="quoted quoted"><span>‹</span><span class="skolem">h</span> <span class="keyword1">analytic_on</span> UNIV<span>›</span></span><span class="main">)</span><span>
          </span><span class="keyword3 command">fix</span> <span class="skolem">i</span><span>
          </span><span class="keyword3 command">assume</span> <span class="quoted quoted"><span>"</span><span class="skolem">i</span> <span class="main">&lt;</span> Suc <span class="skolem">n</span><span>"</span></span><span>
          </span><span class="keyword1 command">then</span> <span class="keyword1 command">have</span> §<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">n</span> <span class="main">∨</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">n</span><span>"</span></span><span>
            </span><span class="keyword1 command">by</span> <span class="operator">linarith</span><span>
          </span><span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span><span class="skolem">h'</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">D</span><span>"</span></span><span>
            </span><span class="keyword1 command">using</span> h'_eq hg d h'_def pwn_nonzero <span class="keyword1 command">by</span> <span class="operator">force</span><span>
          </span><span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span><span class="skolem">h'</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">≠</span> <span class="skolem">g</span> <span class="skolem">i</span> <span class="main">(</span><span class="skolem">w</span> <span class="skolem">i</span><span class="main">)</span><span>"</span></span><span>
            </span><span class="keyword1 command">using</span> § h'_eq hg h'_def d pwn_nonzero <span class="keyword1 command">by</span> <span class="operator">fastforce</span><span>
        </span><span class="keyword1 command">qed</span><span>
      </span><span class="keyword1 command">qed</span><span>
      </span><span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span><span>
        </span><span class="keyword1 command">using</span> ** <span class="main">[</span><span class="operator">OF</span> order_refl<span class="main">]</span> η that gf<span>
        </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> w_def bij_betw_iff_bijections inD_def<span class="main">)</span> <span class="operator">metis</span><span>
    </span><span class="keyword1 command">next</span><span>
      </span><span class="keyword3 command">case</span> False<span>
      </span><span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span><span> ...
      </span><span class="keyword1 command">qed</span><span>
    </span><span class="keyword1 command">qed</span><span>
    </span><span class="keyword1 command">with</span> f <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span><span>
      </span><span class="keyword1 command">using</span> inj <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main main">=</span><span class="quoted quoted"><span>"</span><span class="skolem">h</span><span>"</span></span> <span class="keyword2 keyword quasi_keyword">in</span> exI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> Φ_def inj_on_def<span class="main">)</span><span>
  </span><span class="keyword1 command">qed</span></pre>


The next part of the proof is pure annoyance. We have just shown the main argument of the transfinite construction, yet the following chunk of text seems to be necessary in order to define the family of functions `f` and to perform the transfinite induction itself (the relevant induction rule is called `eps_induct`, for $\epsilon$-induction).

Having done this, we obtain the crucial properties of `f`: the functions are analytic and satisfy $f_\beta (z_\alpha) \in D$ if $\alpha<\beta$; moreover, the enumeration `f` is injective and therefore repetition-free.

<pre class="source">
  <span class="keyword3 command">define</span> <span class="skolem skolem">G</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">G</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">f</span> <span class="bound">γ</span><span class="main">.</span> <span class="main">@</span><span class="bound">h</span><span class="main">.</span> <span class="skolem">Φ</span> <span class="bound">γ</span> <span class="main">(</span><span class="main">(</span>restrict <span class="bound">f</span> <span class="main">(</span>elts <span class="bound">γ</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="bound">γ</span><span class="main">:=</span><span class="bound">h</span><span class="main">)</span><span class="main">)</span><span>"</span></span><span>
  </span><span class="keyword1 command">have</span> nxt<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">Φ</span> <span class="skolem">γ</span> <span class="main">(</span><span class="main">(</span>restrict <span class="skolem">f</span> <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="skolem">γ</span><span class="main">:=</span> <span class="skolem">G</span> <span class="skolem">f</span> <span class="skolem">γ</span><span class="main">)</span><span class="main">)</span><span>"</span></span><span>
    </span><span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">γ</span> <span class="main">∈</span> elts ω1<span>"</span></span> <span class="quoted quoted"><span>"</span><span class="main">∀</span><span class="bound">β</span> <span class="main">∈</span> elts <span class="skolem">γ</span><span class="main">.</span> <span class="skolem">Φ</span> <span class="bound">β</span> <span class="skolem">f</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">f</span> <span class="skolem">γ</span><span>
    </span><span class="keyword1 command">unfolding</span> G_def <span class="keyword1 command">using</span> * <span class="main">[</span><span class="operator">OF</span> that<span class="main">]</span> <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> someI<span class="main">)</span><span>
  </span><span class="keyword1 command">have</span> G_restr<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">G</span> <span class="main">(</span>restrict <span class="skolem">f</span> <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span class="main">)</span> <span class="skolem">γ</span> <span class="main">=</span> <span class="skolem">G</span> <span class="skolem">f</span> <span class="skolem">γ</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">γ</span> <span class="main">∈</span> elts ω1<span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">f</span> <span class="skolem">γ</span><span>
    </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> G_def<span class="main">)</span><span>
  </span><span class="keyword3 command">define</span> <span class="skolem skolem">f</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">f</span> <span class="main">≡</span> transrec <span class="skolem">G</span><span>"</span></span><span>
  </span><span class="keyword1 command">have</span> Φf<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">Φ</span> <span class="skolem">β</span> <span class="skolem">f</span><span>"</span></span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="skolem">β</span> <span class="main">∈</span> elts ω1<span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">β</span><span>
    </span><span class="keyword1 command">using</span> that<span>
  </span><span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted skolem">β</span> <span class="quasi_keyword">rule</span><span class="main main">:</span> eps_induct<span class="main">)</span><span>
    </span><span class="keyword3 command">case</span> <span class="main">(</span>step <span class="skolem">γ</span><span class="main">)</span><span>
    </span><span class="keyword1 command">then</span> <span class="keyword1 command">have</span> *<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">∀</span><span class="bound">β</span><span class="main">∈</span>elts <span class="skolem">γ</span><span class="main">.</span> <span class="skolem">Φ</span> <span class="bound">β</span> <span class="skolem">f</span><span>"</span></span><span>
      </span><span class="keyword1 command">using</span> Ord_ω1 Ord_trans <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
    </span><span class="keyword1 command">have</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted quoted"><span>"</span>inj_on <span class="main">(</span><span class="main">λ</span><span class="bound">β</span><span class="main">.</span> <span class="skolem">G</span> <span class="main">(</span>restrict <span class="skolem">f</span> <span class="main">(</span>elts <span class="bound">β</span><span class="main">)</span><span class="main">)</span> <span class="bound">β</span><span class="main">)</span> <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span> <span class="main">⟷</span> inj_on <span class="skolem">f</span> <span class="main">(</span>elts <span class="skolem">γ</span><span class="main">)</span><span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> <span class="main main">(</span>no_types<span class="main main">,</span> lifting<span class="main main">)</span> f_def transrec inj_on_cong<span class="main">)</span><span>
    </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="skolem">f</span> <span class="skolem">γ</span> <span class="main">=</span> <span class="skolem">G</span> <span class="skolem">f</span> <span class="skolem">γ</span><span>"</span></span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> G_restr transrec f_def step.prems<span class="main">)</span><span>
    </span><span class="keyword1 command">with</span> nxt <span class="main">[</span><span class="operator">OF</span> step.prems<span class="main">]</span> * <span class="keyword3 command">show</span> <span class="var quoted var">?case</span><span>
      </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Φ_def elts_succ fun_upd_same fun_upd_triv inj_on_restrict_eq restrict_upd<span class="main">)</span><span>
  </span><span class="keyword1 command">qed</span><span>
  </span><span class="keyword1 command">then</span> <span class="keyword1 command">have</span> anf<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">⋀</span><span class="bound">β</span><span class="main">.</span> <span class="bound">β</span> <span class="main">∈</span> elts ω1 <span class="main">⟹</span> <span class="skolem">f</span> <span class="bound">β</span> <span class="keyword1">analytic_on</span> UNIV<span>"</span></span><span>
    </span><span class="keyword2 keyword">and</span> inD<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">⋀</span><span class="bound">α</span> <span class="bound">β</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">β</span> <span class="main">∈</span> elts ω1<span class="main">;</span> <span class="bound">α</span> <span class="main">∈</span> elts <span class="bound">β</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">f</span> <span class="bound">β</span> <span class="main">(</span><span class="skolem">ζ</span> <span class="bound">α</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">D</span><span>"</span></span><span>
    </span><span class="keyword1 command">using</span> Φ_def inD_def <span class="keyword1 command">by</span> <span class="operator">blast</span><span class="main keyword3">+</span><span>
  </span><span class="keyword1 command">have</span> injf<span class="main">:</span> <span class="quoted quoted"><span>"</span>inj_on <span class="skolem">f</span> <span class="main">(</span>elts ω1<span class="main">)</span><span>"</span></span><span>
    </span><span class="keyword1 command">using</span> Φf <span class="keyword1 command">unfolding</span> inj_on_def Φ_def <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Ord_ω1 Ord_in_Ord Ord_linear_le in_succ_iff<span class="main">)</span>
</pre>

All that remains is tidying up. We show that the family of functions just constructed returns a countable image for every complex number `z`, which involves finding the corresponding ordinal $\alpha < \omega_1$ using the properties proved for `f`. The Wetzel property and uncountability of the family follow straightforwardly.


<pre class="source">
  <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span><span>
  </span><span class="keyword1 command">proof</span><span>
    </span><span class="keyword1 command">let</span> <span class="var quoted var">?F</span> <span class="main">=</span> <span class="quoted quoted"><span>"</span><span class="skolem">f</span> <span class="main">`</span> elts ω1<span>"</span></span><span>
    </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>countable <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">`</span> <span class="skolem">f</span> <span class="main">`</span> elts ω1<span class="main">)</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">z</span><span>
    </span><span class="keyword1 command">proof</span> <span class="operator">-</span><span>
      </span><span class="keyword3 command">obtain</span> <span class="skolem skolem">α</span> <span class="keyword2 keyword">where</span> α<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">ζ</span> <span class="skolem">α</span> <span class="main">=</span> <span class="skolem">z</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">α</span> <span class="main">∈</span> elts ω1<span>"</span></span> <span class="quoted quoted"><span>"</span>Ord <span class="skolem">α</span><span>"</span></span><span>
        </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">meson</span> Ord_ω1 Ord_in_Ord UNIV_I ζ bij_betw_iff_bijections<span class="main">)</span><span>
      </span><span class="keyword1 command">let</span> <span class="var quoted var">?B</span> <span class="main">=</span> <span class="quoted quoted"><span>"</span>elts ω1 <span class="main">-</span> elts <span class="main">(</span>succ <span class="skolem">α</span><span class="main">)</span><span>"</span></span><span>
      </span><span class="keyword1 command">have</span> eq<span class="main">:</span> <span class="quoted quoted"><span>"</span>elts ω1 <span class="main">=</span> elts <span class="main">(</span>succ <span class="skolem">α</span><span class="main">)</span> <span class="main">∪</span> <span class="var">?B</span><span>"</span></span><span>
        </span><span class="keyword1 command">using</span> α <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Diff_partition Ord_ω1 OrdmemD less_eq_V_def succ_le_iff<span class="main">)</span><span>
      </span><span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">`</span> <span class="skolem">f</span> <span class="main">`</span> <span class="var">?B</span> <span class="main">⊆</span> <span class="skolem">D</span><span>"</span></span><span>
        </span><span class="keyword1 command">using</span> α inD <span class="keyword1 command">by</span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">meson</span> Ord_ω1 Ord_in_Ord Ord_linear<span class="main">)</span><span>
      </span><span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>countable <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">`</span> <span class="skolem">f</span> <span class="main">`</span> <span class="var">?B</span><span class="main">)</span><span>"</span></span><span>
        </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">meson</span> <span class="quoted quoted"><span>‹</span>countable <span class="skolem">D</span><span>›</span></span> countable_subset<span class="main">)</span><span>
      </span><span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>countable <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="bound">f</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">`</span> <span class="skolem">f</span> <span class="main">`</span> elts <span class="main">(</span>succ <span class="skolem">α</span><span class="main">)</span><span class="main">)</span><span>"</span></span><span>
        </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> α less_ω1_imp_countable<span class="main">)</span><span>
      </span><span class="keyword1 command">ultimately</span> <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span><span>
        </span><span class="keyword1 command">using</span> eq <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> countable_Un_iff image_Un<span class="main">)</span><span>
    </span><span class="keyword1 command">qed</span><span>
    </span><span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span>Wetzel <span class="var">?F</span><span>"</span></span><span>
      </span><span class="keyword1 command">unfolding</span> Wetzel_def <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main main">:</span> anf<span class="main">)</span><span>
    </span><span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span>uncountable <span class="var">?F</span><span>"</span></span><span>
      </span><span class="keyword1 command">using</span> Ord_ω1 countable_iff_less_ω1 countable_image_inj_eq injf <span class="keyword1 command">by</span> <span class="operator">blast</span><span>
  </span><span class="keyword1 command">qed</span><span>
</span><span class="keyword1 command">qed</span>
</pre>

### And finally ...

The conclusion simply expresses the two cases as a single formula:

<pre class="source">
<span class="keyword1 command">theorem</span> Erdos_Wetzel<span class="main">:</span> <span class="quoted quoted"><span>"</span>C_continuum <span class="main">=</span> <span class="main">ℵ</span><span class="main">1</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">F</span><span class="main">.</span> Wetzel <span class="bound">F</span> <span class="main">∧</span> uncountable <span class="bound">F</span><span class="main">)</span><span>"</span></span><span>
  </span><span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> C_continuum_ge Erdos_Wetzel_CH Erdos_Wetzel_nonCH TC_small less_V_def<span class="main">)</span>
</pre>

The full theory development [is online](https://www.isa-afp.org/entries/Wetzels_Problem.html).
The project took under three weeks and the most difficult part concerned the material skipped above:
the case where $\gamma$ is infinite, involving the careful construction of an infinite series satisfying all the criteria and showing it to be holomorphic (therefore analytic) using a theorem about uniform limits. Well done if you made it this far!

### Postscript added 26-09-2022

I presented this work in beautiful [Tbilisi](https://www.europeanbestdestinations.com/destinations/tbilisi/) at CICM 2022
(part of the [Computational Logic Autumn Summit](http://viam.science.tsu.ge/clas2022/)).
The full [paper](https://rdcu.be/cWkY5), including details
about the case where $\gamma$ is infinite, is online
with the accompanying
[slides](https://www.cl.cam.ac.uk/~lp15/papers/Alexandria/Wetzel-talk.pdf).

