---
layout: post
title:  "A classical proof: exponentials are irrational"
usemathjax: true
tags: examples, Isabelle, Proofs from THE BOOK
---

In *[Proofs from THE BOOK](https://link.springer.com/book/10.1007/978-3-662-57265-8)*, Aigner and Ziegler
present hundreds of classic proofs from what we might call the mathematical canon, based in large part on suggestions by [Paul Erdős](https://www.ams.org/notices/199801/comm-erdos.pdf).
The authors confine themselves to proofs requiring "only a modest amount of technique from undergraduate mathematics".
Nothing too advanced or specialised, but nevertheless, a selection of insightful techniques across the mathematical landscape.
Here we look at an Isabelle/HOL proof that the exponential function yields irrational numbers.

### Getting started

Let's be precise about that claim: $\exp r$ is irrational for all rational, nonzero $r$. 
Since $\exp(\ln x)=x$, it follows that $\ln r$ is irrational for every positive rational $r≠1$.

The authors present a simple 19th-century [proof](https://proofsfromthebook.github.io/7) (alternative [source](https://planetmath.org/erisirrationalforrinmathbbqsetminus0)) that relies on nothing other than differentiation and integration.
I have recently [formalised it](https://www.isa-afp.org/entries/Irrationals_From_THEBOOK.html) for the Archive of Formal Proofs and we can look at some highlights here.

The proof begins by defining the function

$$ \begin{align*}
f(x) &= \frac{x^n (1-x)^n}{n!}, 
\end{align*} $$

which goes straightforwardly into Isabelle. (You shouldn't reserve `f` for the name of a constant, though.) Note that $n$ above becomes a parameter of the function we define.

<pre class="source">
<span class="keyword1 command entity_def">definition</span> <span class="entity entity_def">hf</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="free">hf</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">λ</span><span class="bound">x</span><span class="main">::</span>real<span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">^</span><span class="bound">n</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">^</span><span class="bound">n</span><span class="main">)</span> <span class="main">/</span> fact <span class="bound">n</span><span>"</span></span>
</pre>

The text notes that the coefficients of $f$ are integers, hinting that this fact is sufficient,
although I could not see a way to carry the proof right to the end without calculating the coefficients exactly. So here they are.

<pre class="source">
<span class="keyword1 command entity_def">definition</span> <span class="entity entity_def">cf</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="free">cf</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">n</span> <span class="bound">i</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">n</span> <span class="keyword1">choose</span> <span class="main">(</span><span class="bound">i</span><span class="main">-</span><span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">^</span><span class="main">(</span><span class="bound">i</span><span class="main">-</span><span class="bound">n</span><span class="main">)</span><span>"</span></span>
</pre>

### A few simple proofs

The proof that they **are** the right coefficients may be instructive.
Sums are tedious to manipulate, especially when we perform a change of variables.
(See below near <span class="dynamic dynamic">sum.reindex</span>, where we change the index range from $0\ldots n$ to $n\ldots 2n$.
The authors did not give an explicit proof of this result (having not even stated what the coefficients were), but had they done so, they probably would have shown many of the steps that appear in the formal proof below.

<pre class="source">
<span class="keyword1 command">lemma</span> hf_int_poly<span class="main">:</span>
  <span class="keyword2 keyword">fixes</span> <span class="free">x</span><span class="main">::</span><span class="quoted">real</span>
  <span class="keyword2 keyword">shows</span> <span class="quoted quoted"><span>"</span>hf</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">1</span> <span class="main">/</span> fact <span class="free">n</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">=</span><span class="main">0</span><span class="main">..</span><span class="numeral">2</span><span class="main">*</span><span class="free">n</span><span class="main">.</span> real_of_int <span class="main">(</span>cf <span class="free">n</span> <span class="bound">i</span><span class="main">)</span> <span class="main">*</span> <span class="bound">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span><span>"</span>
<span class="keyword1 command">proof</span>
  <span class="keyword3 command">fix</span> <span class="skolem">x</span>
  <span class="keyword1 command">have</span> inj<span class="main">:</span> <span class="quoted quoted"><span>"</span>inj_on <span class="main">(</span><span class="main">(+)</span><span class="free">n</span><span class="main">)</span> <span class="main">{..</span><span class="free">n</span><span class="main">}</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> inj_on_def<span class="main">)</span>
  <span class="keyword1 command">have</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="main">(+)</span><span class="free">n</span><span class="main">)</span> <span class="main">`</span> <span class="main">{..</span><span class="free">n</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="free">n</span><span class="main">..</span><span class="numeral">2</span><span class="main">*</span><span class="free">n</span><span class="main">}</span><span>"</span></span>
    <span class="keyword1 command">using</span> nat_le_iff_add <span class="keyword1 command">by</span> <span class="operator">fastforce</span>
  <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="skolem">x</span><span class="main">^</span><span class="free">n</span> <span class="main">*</span> <span class="main">(</span><span class="main">-</span><span class="skolem">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">^</span><span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">^</span> <span class="free">n</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">≤</span><span class="free">n</span><span class="main">.</span> real <span class="main">(</span><span class="free">n</span> <span class="keyword1">choose</span> <span class="bound">k</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">-</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">^</span> <span class="bound">k</span><span class="main">)</span><span>"</span></span>
    <span class="keyword1 command">unfolding</span> binomial_ring <span class="keyword1 command">by</span> <span class="operator">simp</span>
  <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">^</span> <span class="free">n</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">≤</span><span class="free">n</span><span class="main">.</span> real_of_int <span class="main">(</span><span class="main">(</span><span class="free">n</span> <span class="keyword1">choose</span> <span class="bound">k</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">^</span><span class="bound">k</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">x</span> <span class="main">^</span> <span class="bound">k</span><span class="main">)</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> mult.assoc <span class="quasi_keyword">flip</span><span class="main main">:</span> power_minus<span class="main">)</span>
  <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">≤</span><span class="free">n</span><span class="main">.</span> real_of_int <span class="main">(</span><span class="main">(</span><span class="free">n</span> <span class="keyword1">choose</span> <span class="bound">k</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">^</span><span class="bound">k</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">x</span> <span class="main">^</span> <span class="main">(</span><span class="free">n</span><span class="main">+</span><span class="bound">k</span><span class="main">)</span><span class="main">)</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> sum_distrib_left mult_ac power_add<span class="main">)</span>
  <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">=</span><span class="free">n</span><span class="main">..</span><span class="numeral">2</span><span class="main">*</span><span class="free">n</span><span class="main">.</span> real_of_int <span class="main">(</span>cf</span> <span class="free">n</span> <span class="bound">i</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> sum.reindex <span class="main main">[</span><span class="operator">OF</span> inj<span class="main main">,</span> <span class="operator">simplified</span><span class="main main">]</span> cf_def<span class="main">)</span>
  <span class="keyword1 command">finally</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>hf</span> <span class="free">n</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">/</span> fact <span class="free">n</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> <span class="free">n</span><span class="main">..</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span><span class="main">.</span> real_of_int <span class="main">(</span>cf <span class="free">n</span> <span class="bound">i</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> hf_def<span class="main">)</span>
  <span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">.</span> real_of_int <span class="main">(</span>cf</span> <span class="free">n</span> <span class="bound">i</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> cf_def<span class="main">)</span>
  <span class="keyword1 command">ultimately</span> <span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span>hf</span> <span class="free">n</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">/</span> fact <span class="free">n</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">..</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span><span class="main">.</span> real_of_int <span class="main">(</span>cf <span class="free">n</span> <span class="bound">i</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span><span>"</span>
    <span class="keyword1 command">using</span> sum.union_disjoint <span class="main">[</span><span class="operator">of</span> <span class="quoted quoted"><span>"</span><span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="main">{</span><span class="free">n</span><span class="main">..</span><span class="numeral">2</span><span class="main">*</span><span class="free">n</span><span class="main">}</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> real_of_int <span class="main">(</span>cf</span> <span class="free">n</span> <span class="bound">i</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">x</span><span class="main">^</span><span class="bound">i</span><span>"</span><span class="main">]</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> ivl_disj_int_two<span class="main main">(</span>7<span class="main main">)</span> ivl_disj_un_two<span class="main main">(</span>7<span class="main main">)</span> mult_2<span class="main">)</span>
<span class="keyword1 command">qed</span>
</pre>

The text states the following fact about $f$ (for any given $n$) with strict inequalities. This non-strict version is easier to prove (one single line) and is all we need.
<pre class="source">
<span class="keyword1 command entity_def" id="offset_2207..2212">lemma</span>
  <span class="keyword2 keyword">assumes</span> <span class="quoted quoted"><span>"</span><span class="main">0</span> <span class="main">≤</span> <span class="free">x</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="free">x</span> <span class="main">≤</span> <span class="main">1</span><span>"</span></span>
  <span class="keyword2 keyword">shows</span> hf_nonneg<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">0</span> <span class="main">≤</span> hf</span> <span class="free">n</span> <span class="free">x</span><span>"</span> <span class="keyword2 keyword">and</span> hf_le_inverse_fact<span class="main">:</span> <span class="quoted quoted"><span>"</span>hf</span> <span class="free">n</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">1</span><span class="main">/</span>fact <span class="free">n</span><span>"</span>
  <span class="keyword1 command">using</span> assms <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> hf_def <span class="dynamic dynamic">divide_simps</span> mult_le_one power_le_one<span class="main">)</span>  
</pre>

That $f$ is differentiable is proved by calculating and discarding its derivative.
This task is trivial thanks to the trick of using built-in bundles of rules for derivatives, which we have [seen before]({% post_url 2021-12-22-MVT-example %}).

<pre class="source">
<span class="keyword1 command">lemma</span> hf_differt <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted quoted"><span>"</span>hf</span> <span class="free">n</span> <span class="keyword1">differentiable</span> <span class="keyword1">at</span> <span class="free">x</span><span>"</span>
  <span class="keyword1 command">unfolding</span> hf_int_poly differentiable_def
  <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic dynamic">derivative_eq_intros</span> exI <span class="main keyword3">|</span> <span class="operator">simp</span><span class="main">)</span><span class="main keyword3">+</span>
</pre>

The following derivative calculation takes a dozen-plus lines to prove because the result that emerges automatically needs to have its index shifted by one.
The (omitted) manipulations resemble those we've just seen.

<pre class="source">
<span class="keyword1 command">lemma</span> deriv_sum_int<span class="main">:</span>
  <span class="quoted quoted"><span>"</span>deriv <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">∑</span><span class="bound">i</span><span class="main">=</span><span class="main">0</span><span class="main">..</span><span class="free">n</span><span class="main">.</span> of_int <span class="main">(</span><span class="free">c</span> <span class="bound">i</span><span class="main">)</span> <span class="main">*</span> <span class="bound">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span> <span class="free">x</span>
     <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span><span class="main">=</span><span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">=</span><span class="main">0</span><span class="main">..</span><span class="free">n</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">.</span> real_of_int <span class="main">(</span><span class="main">(</span>int <span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="free">c</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="free">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span><span>"</span></span>
</pre>

### Reasoning about iterated derivatives by induction

We have been working towards proving a claim in the text: that the derivatives $f^{(k)} (0)$ and $f^{(k)} (1)$ are integers for all $k\ge0$. The text contains a four line argument only, but it seems essential to calculate the $k$-th derivatives exactly. 
The proof, somewhat cluttered with conversions from type `nat` to `int` to `real`, is by induction on $k$. We are dealing with products of sets of integers. 

<pre class="source">
<span class="keyword1 command">lemma</span> hf_deriv_int_poly<span class="main">:</span>
   <span class="quoted quoted"><span>"</span><span class="main">(</span>deriv<span class="main">^^</span><span class="free">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">1/</span>fact <span class="free">n</span><span class="main">)*(∑</span><span class="bound">i</span><span class="main">=</span><span class="main">0</span><span class="main">..</span><span class="numeral">2</span><span class="main">*</span><span class="free">n</span><span class="main">-</span><span class="free">k</span><span class="main">.</span> of_int<span class="main">(</span>int<span class="main">(</span><span class="main">∏</span><span class="main">{</span><span class="bound">i</span><span class="main">&lt;..</span><span class="bound">i</span><span class="main">+</span><span class="free">k</span><span class="main">}</span><span class="main">)</span> <span class="main">*</span> cf <span class="free">n</span> <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="free">k</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="bound">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span><span>"</span>
<span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted free">k</span><span class="main">)</span>
  <span class="keyword3 command">case</span> 0
  <span class="keyword3 command">show</span> <span class="var quoted var">?case</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> hf_int_poly<span class="main">)</span>
<span class="keyword1 command">next</span>
  <span class="keyword3 command">case</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword3 command entity_def" id="offset_3776..3782">define</span> <span class="skolem skolem">F</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">..</span><span class="numeral">2</span><span class="main">*</span><span class="free">n</span> <span class="main">-</span> <span class="skolem">k</span><span class="main">.</span> real_of_int <span class="main">(</span>int<span class="main">(</span><span class="main">∏</span><span class="main">{</span><span class="bound">i</span><span class="main">&lt;..</span><span class="bound">i</span><span class="main">+</span><span class="skolem">k</span><span class="main">}</span><span class="main">)</span> <span class="main">*</span> cf</span> <span class="free">n</span> <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="bound">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span><span>"</span>
  <span class="keyword1 command">have</span> Fd<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">F</span> <span class="keyword1">field_differentiable</span> <span class="keyword1">at</span> <span class="skolem">x</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">x</span>
    <span class="keyword1 command">unfolding</span> field_differentiable_def F_def
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic dynamic">derivative_eq_intros</span> exI <span class="main keyword3">|</span> <span class="operator">force</span><span class="main">)</span><span class="main keyword3">+</span>
  <span class="keyword1 command">have</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted quoted"><span>"</span>prod int <span class="main">{</span><span class="skolem">i</span><span class="main">&lt;..</span>Suc <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="skolem">k</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">+</span> int <span class="skolem">i</span><span class="main">)</span> <span class="main">*</span> prod int <span class="main">{</span>Suc <span class="skolem">i</span><span class="main">&lt;..</span>Suc <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="skolem">k</span><span class="main">)</span><span class="main">}</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">i</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> Suc_le_mono atLeastSucAtMost_greaterThanAtMost le_add1 of_nat_Suc prod.head<span class="main">)</span>
  <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>deriv <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">F</span> <span class="bound">x</span> <span class="main">/</span> fact <span class="free">n</span><span class="main">)</span> <span class="skolem">x</span>
      <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">..</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span> <span class="main">-</span> Suc <span class="skolem">k</span><span class="main">.</span> of_int <span class="main">(</span>int<span class="main">(</span><span class="main">∏</span><span class="main">{</span><span class="bound">i</span><span class="main">&lt;..</span><span class="bound">i</span><span class="main">+</span> Suc <span class="skolem">k</span><span class="main">}</span><span class="main">)</span> <span class="main">*</span> cf</span> <span class="free">n</span> <span class="main">(</span>Suc <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="skolem">k</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">x</span><span class="main">^</span><span class="bound">i</span><span class="main">)</span> <span class="main">/</span> fact <span class="free">n</span><span>"</span> <span class="keyword2 keyword">for</span> <span class="skolem">x</span>
    <span class="keyword1 command">unfolding</span> deriv_cdivide_right <span class="main">[</span><span class="operator">OF</span> Fd<span class="main">]</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> F_def deriv_sum_int cf_def <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main main">:</span> of_int_mult <span class="quasi_keyword">intro</span><span class="main main">:</span> sum.cong<span class="main">)</span>
  <span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="var quoted var">?case</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> Suc F_def<span class="main">)</span>
<span class="keyword1 command">qed</span>
</pre>

So the derivative $f^{(k)} (0)$ is indeed an integer.

<pre class="source">
<span class="keyword1 command">lemma</span> hf_deriv_0<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>deriv<span class="main">^^</span><span class="free">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">0</span> <span class="main">∈</span> <span class="main">ℤ</span><span>"</span>
<span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted quoted"><span>"</span><span class="free">n</span> <span class="main">≤</span> <span class="free">k</span><span>"</span></span><span class="main">)</span>
  <span class="keyword3 command">case</span> True
  <span class="keyword1 command">then</span> <span class="keyword3 command">obtain</span> <span class="skolem skolem">j</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>fact <span class="free">k</span><span class="main">::</span>real<span class="main">)</span> <span class="main">=</span> real_of_int <span class="skolem">j</span> <span class="main">*</span> fact <span class="free">n</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> fact_dvd dvd_def mult.commute of_int_fact of_int_mult<span class="main">)</span>
  <span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>prod real <span class="main">{</span><span class="main">0</span><span class="main">&lt;..</span><span class="free">k</span><span class="main">}</span> <span class="main">=</span> fact <span class="free">k</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> fact_prod atLeastSucAtMost_greaterThanAtMost<span class="main">)</span>
  <span class="keyword1 command">ultimately</span> <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> hf_deriv_int_poly dvd_def<span class="main">)</span>
<span class="keyword1 command">next</span>
  <span class="keyword3 command">case</span> False
  <span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="var quoted var">?thesis</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> hf_deriv_int_poly cf_def<span class="main">)</span>
<span class="keyword1 command">qed</span>
</pre>

To prove that $f^{(k)} (1)$ is also an integer, we have to work harder.
First we prove that $f'(x) = - {f'(1-x)}$.
The proof is annoyingly long because to write the chain rule you need to make the function composition explicit.

<pre class="source">
<span class="keyword1 command">lemma</span> deriv_hf_minus<span class="main">:</span> <span class="quoted quoted"><span>"</span>deriv <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">-</span> deriv <span class="main">(</span>hf <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span>"</span>
<span class="keyword1 command">proof</span>
  <span class="keyword3 command">fix</span> <span class="skolem">x</span>
  <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>hf</span> <span class="free">n</span> <span class="main">=</span> hf <span class="free">n</span> <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> fun_eq_iff hf_def mult.commute<span class="main">)</span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>deriv <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> deriv <span class="main">(</span>hf <span class="free">n</span> <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="operator">fastforce</span>
  <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">=</span> deriv <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="skolem">x</span><span class="main">)</span> <span class="main">*</span> deriv <span class="main">(</span><span class="main">(-)</span> <span class="main">1</span><span class="main">)</span> <span class="skolem">x</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">intro</span> real_derivative_chain<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1 command">finally</span> <span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span>deriv <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">-</span> deriv <span class="main">(</span>hf <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="skolem">x</span><span class="main">)</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="operator">simp</span>
<span class="keyword1 command">qed</span>
</pre>

Then we need a quick proof that all the necessary derivatives exist.

<pre class="source">
<span class="keyword1 command">lemma</span> deriv_n_hf_diffr <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>deriv<span class="main">^^</span><span class="free">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">field_differentiable</span> <span class="keyword1">at</span> <span class="free">x</span><span>"</span>
  <span class="keyword1 command">unfolding</span> field_differentiable_def hf_deriv_int_poly
  <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">rule</span> <span class="dynamic dynamic">derivative_eq_intros</span> exI <span class="main keyword3">|</span> <span class="operator">force</span><span class="main">)</span><span class="main keyword3">+</span>
</pre>

Then, we prove another claim about $k$-th derivatives: that $f^{(k)}(x) = (−1)^k f^{(k)}(1−x)$.
It is an easy induction.

<pre class="source">
<span class="keyword1 command">lemma</span> deriv_n_hf_minus<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>deriv<span class="main">^^</span><span class="free">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">^</span><span class="free">k</span> <span class="main">*</span> <span class="main">(</span>deriv<span class="main">^^</span><span class="free">k</span><span class="main">)</span> <span class="main">(</span>hf <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span>"</span>
<span class="keyword1 command">proof</span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted free">k</span><span class="main">)</span>
  <span class="keyword3 command">case</span> 0
  <span class="keyword1 command">then</span> <span class="keyword3 command">show</span> <span class="var quoted var">?case</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> fun_eq_iff hf_def<span class="main">)</span>
<span class="keyword1 command">next</span>
  <span class="keyword3 command">case</span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1 command">have</span> o<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span>deriv <span class="main">^^</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>deriv <span class="main">^^</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf <span class="free">n</span><span class="main">)</span> <span class="main">∘</span> <span class="main">(-)</span> <span class="main">1</span><span>"</span>
    <span class="keyword1 command">by</span> <span class="operator">auto</span>
  <span class="keyword3 command">show</span> <span class="var quoted var">?case</span>
  <span class="keyword1 command">proof</span>
    <span class="keyword3 command">fix</span> <span class="skolem">x</span>
    <span class="keyword1 command">have</span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="main">(</span>deriv<span class="main">^^</span><span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">∘</span> <span class="main">(-)</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">field_differentiable</span> <span class="keyword1">at</span> <span class="skolem">x</span><span>"</span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main main">:</span> field_differentiable_compose<span class="main">)</span>
    <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>deriv <span class="main">^^</span> Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> deriv <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">^</span> <span class="skolem">k</span> <span class="main">*</span> <span class="main">(</span>deriv <span class="main">^^</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span><span>"</span>
      <span class="keyword1 command">by</span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> Suc<span class="main">)</span>
    <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">^</span> <span class="skolem">k</span> <span class="main">*</span> deriv <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span>deriv <span class="main">^^</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span><span>"</span>
      <span class="keyword1 command">using</span> o <span class="keyword1 command">by</span> <span class="operator">fastforce</span>
    <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">^</span> Suc <span class="skolem">k</span> <span class="main">*</span> <span class="main">(</span>deriv <span class="main">^^</span> Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="skolem">x</span><span class="main">)</span><span>"</span>
      <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">subst</span> o<span class="main keyword3">,</span> <span class="operator">subst</span> deriv_chain<span class="main keyword3">,</span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1 command">finally</span> <span class="keyword3 command">show</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>deriv <span class="main">^^</span> Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">^</span> Suc <span class="skolem">k</span> <span class="main">*</span> <span class="main">(</span>deriv <span class="main">^^</span> Suc <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>hf <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">1</span><span class="main">-</span><span class="skolem">x</span><span class="main">)</span><span>"</span> <span class="keyword1 command">.</span>
  <span class="keyword1 command">qed</span>
<span class="keyword1 command">qed</span>
</pre>

Finally we are able to show that the derivatives $f^{(k)} (1)$ are all integers.
Moreover, for $k>2n$, the derivatives vanish.

<pre class="source">
<span class="keyword1 command">lemma</span> hf_deriv_1<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>deriv<span class="main">^^</span><span class="free">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">1</span> <span class="main">∈</span> <span class="main">ℤ</span><span>"</span>
  <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">,</span><span> best</span><span class="main main">)</span> Ints_1 Ints_minus Ints_mult Ints_power deriv_n_hf_minus hf_deriv_0<span class="main">)</span>

<span class="keyword1 command">lemma</span> hf_deriv_eq_0<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="free">k</span> <span class="main">&gt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">n</span> <span class="main">⟹</span> <span class="main">(</span>deriv<span class="main">^^</span><span class="free">k</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">0</span><span class="main">)</span><span>"</span>
  <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> cf_def hf_deriv_int_poly<span class="main">)</span>
</pre>

### Time for the big one

The main argument lies in the proof that all integer exponentials are irrational. 
We assume that $\exp s$ has the form $a/b$ where $s$, $a$, $b>0$.
We define $n$ as the larger of $a^2$ and $3s^3$, from which we eventually prove that
$n! > as^{2n+1}$.
We define

$$ \begin{align*}
F(x) = \sum_{i\le 2n} (-1)^i  s^{2n-i} f^{(i)} (x). 
\end{align*} $$

and then show that

$$ \begin{align*}
F'(x) = -{sF(x)} + s^{2n+1} f(x).
\end{align*} $$

We put $N = aF(1) − bF(0)$, show $N$ to be an integer, and eventually show by bounding an integral that $0<N<1$, contradiction. A few subproofs of a dozen or so lines are omitted below. The full development is [available online](https://www.isa-afp.org/browser_info/current/AFP/Irrationals_From_THEBOOK/Irrationals_From_THEBOOK.html).

<pre class="source">
<span class="keyword1 command entity_def" id="offset_6847..6852">lemma</span> exp_nat_irrational<span class="main">:</span>
  <span class="keyword2 keyword">assumes</span> <span class="quoted quoted"><span>"</span><span class="free">s</span> <span class="main">&gt;</span> <span class="main">0</span><span>"</span></span> <span class="keyword2 keyword">shows</span> <span class="quoted quoted"><span>"</span>exp <span class="main">(</span>real_of_int <span class="free">s</span><span class="main">)</span> <span class="main">∉</span> <span class="main">ℚ</span><span>"</span></span>
<span class="keyword1 command">proof</span>
  <span class="keyword3 command">assume</span> <span class="quoted quoted"><span>"</span>exp <span class="main">(</span>real_of_int <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">ℚ</span><span>"</span></span>
  <span class="keyword1 command">then</span> <span class="keyword3 command">obtain</span> <span class="skolem skolem">a</span> <span class="skolem skolem">b</span> <span class="keyword2 keyword">where</span> ab<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">a</span> <span class="main">&gt;</span> <span class="main">0</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">b</span> <span class="main">&gt;</span> <span class="main">0</span><span>"</span></span> <span class="quoted quoted"><span>"</span>coprime <span class="skolem">a</span> <span class="skolem">b</span><span>"</span></span> <span class="keyword2 keyword">and</span> exp_s<span class="main">:</span> <span class="quoted quoted"><span>"</span>exp <span class="free">s</span> <span class="main">=</span> of_int <span class="skolem">a</span> <span class="main">/</span> of_int <span class="skolem">b</span><span>"</span></span>
    <span class="keyword1 command">using</span> <span>Rats_cases'</span> div_0 exp_not_eq_zero of_int_0
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">,</span><span> best</span><span class="main main">)</span> exp_gt_zero of_int_0_less_iff zero_less_divide_iff<span class="main">)</span>
  <span class="keyword3 command entity_def" id="offset_7196..7202">define</span> <span class="skolem skolem">n</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">n</span> <span class="main">≡</span> nat <span class="main">(</span>max <span class="main">(</span><span class="skolem">a</span><span class="main">^</span><span class="numeral">2</span><span class="main">)</span> <span class="main">(</span><span class="numeral">3</span> <span class="main">*</span> <span class="free">s</span><span class="main">^</span><span class="numeral">3</span><span class="main">)</span><span class="main">)</span><span>"</span></span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> ns3<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="free">s</span><span class="main">^</span><span class="numeral">3</span> <span class="main">≤</span> real <span class="skolem">n</span> <span class="main">/</span> <span class="numeral">3</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="operator">linarith</span>
  <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="skolem">n</span> <span class="main">&gt;</span> <span class="main">0</span><span>"</span></span>
    <span class="keyword1 command">using</span> <span class="quoted quoted"><span>‹</span><span class="skolem">a</span> <span class="main">&gt;</span> <span class="main">0</span><span>›</span></span> n_def <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">,</span><span> best</span><span class="main main">)</span> zero_less_nat_eq zero_less_power<span class="main">)</span>
  <span class="keyword1 command">have</span> s_le<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="free">s</span> <span class="main">^</span> <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">/</span> exp <span class="main">1</span><span class="main">)</span> <span class="main">^</span> <span class="skolem">n</span><span>"</span></span>
    <em>omitted</em>
  <span class="keyword1 command">have</span> a_less<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">a</span> <span class="main">&lt;</span> sqrt <span class="main">(</span><span class="numeral">2</span><span class="main">*</span>pi<span class="main">*</span><span class="skolem">n</span><span class="main">)</span><span>"</span></span>
    <em>omitted</em>
  <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>sqrt <span class="main">(</span><span class="numeral">2</span><span class="main">*</span>pi<span class="main">*</span><span class="skolem">n</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">/</span> exp <span class="main">1</span><span class="main">)</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">&gt;</span> <span class="skolem">a</span> <span class="main">*</span> <span class="free">s</span> <span class="main">^</span> <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span>"</span></span>
    <span class="keyword1 command">using</span> mult_strict_right_mono <span class="main">[</span><span class="operator">OF</span> a_less<span class="main">]</span> mult_left_mono <span class="main">[</span><span class="operator">OF</span> s_le<span class="main">]</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">,</span><span> best</span><span class="main main">)</span> s_le ab<span class="main main">(</span>1<span class="main main">)</span> assms of_int_1 of_int_le_iff of_int_mult zero_less_power<span class="main">)</span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> n<span class="main">:</span> <span class="quoted quoted"><span>"</span>fact <span class="skolem">n</span> <span class="main">&gt;</span> <span class="skolem">a</span> <span class="main">*</span> <span class="free">s</span> <span class="main">^</span> <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span>"</span></span>
    <span class="keyword1 command">using</span> fact_bounds<span class="main">(</span>1<span class="main">)</span> <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">,</span><span> best</span><span class="main main">)</span> <span class="quoted quoted"><span>‹</span><span class="main">0</span> <span class="main">&lt;</span> <span class="skolem">n</span><span>›</span></span> of_int_fact of_int_less_iff<span class="main">)</span>
  <span class="keyword3 command entity_def" id="offset_8597..8603">define</span> <span class="skolem skolem">F</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">F</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">∑</span><span class="bound">i</span><span class="main">≤</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">.</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">^</span><span class="bound">i</span> <span class="main">*</span> <span class="free">s</span><span class="main">^</span><span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">-</span><span class="bound">i</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>deriv<span class="main">^^</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span>hf</span> <span class="skolem">n</span><span class="main">)</span> <span class="bound">x</span><span>"</span>
  <span class="keyword1 command">have</span> Fder <span class="main">[</span><span class="operator">derivative_intros</span><span class="main">]</span><span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="skolem">F</span> <span class="keyword1">has_real_derivative</span> <span class="main">-</span><span class="free">s</span> <span class="main">*</span> <span class="skolem">F</span> <span class="skolem">x</span> <span class="main">+</span> <span class="free">s</span> <span class="main">^</span> <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">*</span> hf</span> <span class="skolem">n</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">at</span> <span class="skolem">x</span><span class="main">)</span><span>"</span> <span class="keyword2 keyword">for</span> <span class="skolem">x</span>
    <em>omitted</em>
  <span class="keyword1 command">have</span> F01_Ints<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="skolem">F</span> <span class="main">0</span> <span class="main">∈</span> <span class="main">ℤ</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">F</span> <span class="main">1</span> <span class="main">∈</span> <span class="main">ℤ</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main main">:</span> F_def hf_deriv_0 hf_deriv_1 Ints_sum<span class="main">)</span>
  <span class="keyword3 command entity_def" id="offset_9898..9904">define</span> <span class="skolem skolem">sF</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">sF</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span><span class="main">.</span> exp <span class="main">(</span>of_int <span class="free">s</span> <span class="main">*</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">F</span> <span class="bound">x</span><span>"</span></span>
  <span class="keyword3 command entity_def" id="offset_9952..9958">define</span> <span class="skolem skolem">sF'</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">sF'</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">x</span><span class="main">.</span> of_int <span class="free">s</span> <span class="main">^</span> Suc<span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>exp <span class="main">(</span>of_int <span class="free">s</span> <span class="main">*</span> <span class="bound">x</span><span class="main">)</span> <span class="main">*</span> hf</span> <span class="skolem">n</span> <span class="bound">x</span><span class="main">)</span><span>"</span>
  <span class="keyword1 command">have</span> sF_der<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="skolem">sF</span> <span class="keyword1">has_real_derivative</span> <span class="skolem">sF'</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">at</span> <span class="skolem">x</span><span class="main">)</span><span>"</span></span> <span class="keyword2 keyword">for</span> <span class="skolem">x</span>
    <span class="keyword1 command">unfolding</span> sF_def sF'_def
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">rule</span> refl <span class="dynamic dynamic">derivative_eq_intros</span> <span class="main keyword3">|</span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main main">:</span> <span class="dynamic dynamic">algebra_simps</span><span class="main">)</span><span class="main keyword3">+</span>
  <span class="keyword1 command">let</span> <span class="var quoted var">?N</span> <span class="main">=</span> <span class="quoted quoted"><span>"</span><span class="skolem">b</span> <span class="main">*</span> integral <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">1</span><span class="main">}</span> <span class="skolem">sF'</span><span>"</span></span>
  <span class="keyword1 command">have</span> sF'_integral<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="skolem">sF'</span> <span class="keyword1">has_integral</span> <span class="skolem">sF</span> <span class="main">1</span> <span class="main">-</span> <span class="skolem">sF</span> <span class="main">0</span><span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">1</span><span class="main">}</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">)</span> fundamental_theorem_of_calculus has_vector_derivative_at_within
            has_field_derivative_iff_has_vector_derivative sF_der<span class="main">)</span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="var">?N</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">*</span> <span class="skolem">F</span> <span class="main">1</span> <span class="main">-</span> <span class="skolem">b</span> <span class="main">*</span> <span class="skolem">F</span> <span class="main">0</span><span>"</span></span>
    <span class="keyword1 command">using</span> <span class="quoted quoted"><span>‹</span><span class="skolem">b</span> <span class="main">&gt;</span> <span class="main">0</span><span>›</span></span> <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> integral_unique exp_s sF_def <span class="dynamic dynamic">algebra_simps</span><span class="main">)</span>
  <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">∈</span> <span class="main">ℤ</span><span>"</span></span>
    <span class="keyword1 command">using</span> hf_deriv_1 <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> F01_Ints<span class="main">)</span>
  <span class="keyword1 command">finally</span> <span class="keyword1 command">have</span> N_Ints<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="var">?N</span> <span class="main">∈</span> <span class="main">ℤ</span><span>"</span></span> <span class="keyword1 command">.</span>
  <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="skolem">sF'</span> <span class="main">(</span><span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span><span>"</span></span> <span class="keyword2 keyword">and</span> ge0<span class="main">:</span> <span class="quoted quoted"><span>"</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">1</span><span class="main">}</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> <span class="skolem">sF'</span> <span class="bound">x</span><span>"</span></span>
    <span class="keyword1 command">using</span> assms <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> sF'_def hf_def<span class="main">)</span>
  <span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>continuous_on <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">1</span><span class="main">}</span> <span class="skolem">sF'</span><span>"</span></span>
    <span class="keyword1 command">unfolding</span> sF'_def hf_def <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">intro</span> <span class="dynamic dynamic">continuous_intros</span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1 command">ultimately</span> <span class="keyword1 command entity_def" id="offset_10874..10878">have</span> <span class="quoted">False</span> <span class="keyword2 keyword">if</span> <span class="quoted quoted"><span>"</span><span class="main">(</span><span class="skolem">sF'</span> <span class="keyword1">has_integral</span> <span class="main">0</span><span class="main">)</span> <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">1</span><span class="main">}</span><span>"</span></span>
    <span class="keyword1 command">using</span> has_integral_0_cbox_imp_0 <span class="main">[</span><span class="operator">of</span> <span class="quoted main">0</span> <span class="quoted main">1</span> <span class="quoted skolem">sF'</span> <span class="quoted quoted"><span>"</span><span class="main">1</span><span class="main">/</span><span class="numeral">2</span><span>"</span></span><span class="main">]</span> that <span class="keyword1 command">by</span> <span class="operator">auto</span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>integral <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">1</span><span class="main">}</span> <span class="skolem">sF'</span> <span class="main">&gt;</span> <span class="main">0</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> ge0 has_integral_nonneg integral_unique order_le_less sF'_integral<span class="main">)</span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">0</span> <span class="main">&lt;</span> <span class="var">?N</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> <span class="quoted quoted"><span>‹</span><span class="skolem">b</span> <span class="main">&gt;</span> <span class="main">0</span><span>›</span></span><span class="main">)</span>
  <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>integral <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">1</span><span class="main">}</span> <span class="skolem">sF'</span> <span class="main">=</span> of_int <span class="free">s</span> <span class="main">^</span> Suc<span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">)</span> <span class="main">*</span> integral <span class="main">{</span><span class="main">0</span><span class="main">..</span><span class="main">1</span><span class="main">}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> exp <span class="main">(</span><span class="free">s</span><span class="main">*</span><span class="bound">x</span><span class="main">)</span> <span class="main">*</span> hf</span> <span class="skolem">n</span> <span class="bound">x</span><span class="main">)</span><span>"</span>
    <span class="keyword1 command">unfolding</span> sF'_def <span class="keyword1 command">by</span> <span class="operator">force</span>
  <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">≤</span> of_int <span class="free">s</span> <span class="main">^</span> Suc<span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>exp <span class="free">s</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">/</span> fact <span class="skolem">n</span><span class="main">)</span><span class="main">)</span><span>"</span></span>
    <em>omitted</em>
  <span class="keyword1 command">finally</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="var">?N</span> <span class="main">≤</span> <span class="skolem">b</span> <span class="main">*</span> of_int <span class="free">s</span> <span class="main">^</span> Suc<span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="skolem">n</span><span class="main">)</span> <span class="main">*</span> exp <span class="free">s</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">/</span> fact <span class="skolem">n</span><span class="main">)</span><span>"</span></span>
    <span class="keyword1 command">using</span> <span class="quoted quoted"><span>‹</span><span class="skolem">b</span> <span class="main">&gt;</span> <span class="main">0</span><span>›</span></span> <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> sF'_def mult_ac <span class="dynamic dynamic">divide_simps</span><span class="main">)</span>
  <span class="keyword1 command">also</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">...</span> <span class="main">&lt;</span> <span class="main">1</span><span>"</span></span>
    <span class="keyword1 command">using</span> n <span class="keyword1 command improper command">apply</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> <span class="dynamic dynamic">field_simps</span> exp_s<span class="main">)</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> of_int_fact of_int_less_iff of_int_mult of_int_power<span class="main">)</span>
  <span class="keyword1 command">finally</span> <span class="keyword3 command">show</span> <span class="quoted">False</span>
    <span class="keyword1 command">using</span> <span class="quoted quoted"><span>‹</span><span class="main">0</span> <span class="main">&lt;</span> <span class="var">?N</span><span>›</span></span> Ints_cases N_Ints <span class="keyword1 command">by</span> <span class="operator">force</span>
<span class="keyword1 command">qed</span>
</pre>

The full result, for rational arguments, should be clear from the Isabelle text alone.

<pre class="source">
<span class="keyword1 command entity_def">theorem</span> exp_irrational<span class="main">:</span>
  <span class="keyword2 keyword">fixes</span> <span class="free">q</span><span class="main">::</span><span class="quoted">real</span> <span class="keyword2 keyword">assumes</span> <span class="quoted quoted"><span>"</span><span class="free">q</span> <span class="main">∈</span> <span class="main">ℚ</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="free">q</span> <span class="main">≠</span> <span class="main">0</span><span>"</span></span> <span class="keyword2 keyword">shows</span> <span class="quoted quoted"><span>"</span>exp <span class="free">q</span> <span class="main">∉</span> <span class="main">ℚ</span><span>"</span></span>
<span class="keyword1 command">proof</span>
  <span class="keyword3 command">assume</span> q<span class="main">:</span> <span class="quoted quoted"><span>"</span>exp <span class="free">q</span> <span class="main">∈</span> <span class="main">ℚ</span><span>"</span></span>
  <span class="keyword3 command">obtain</span> <span class="skolem skolem">s</span> <span class="skolem skolem">t</span> <span class="keyword2 keyword">where</span> <span class="quoted quoted"><span>"</span><span class="skolem">s</span> <span class="main">≠</span> <span class="main">0</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="skolem">t</span> <span class="main">&gt;</span> <span class="main">0</span><span>"</span></span> <span class="quoted quoted"><span>"</span><span class="free">q</span> <span class="main">=</span> of_int <span class="skolem">s</span> <span class="main">/</span> of_int <span class="skolem">t</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">metis</span> <span>Rats_cases'</span> assms div_0 of_int_0<span class="main">)</span>
  <span class="keyword1 command">then</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span><span class="main">(</span>exp <span class="free">q</span><span class="main">)</span> <span class="main">^</span> <span class="main">(</span>nat <span class="skolem">t</span><span class="main">)</span> <span class="main">=</span> exp <span class="skolem">s</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">,</span><span> best</span><span class="main main">)</span> exp_divide_power_eq of_nat_nat zero_less_nat_eq<span class="main">)</span>
  <span class="keyword1 command">moreover</span> <span class="keyword1 command">have</span> <span class="quoted quoted"><span>"</span>exp <span class="free">q</span> <span class="main">^</span> <span class="main">(</span>nat <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> <span class="main">ℚ</span><span>"</span></span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main main">:</span> q<span class="main">)</span>
  <span class="keyword1 command">ultimately</span> <span class="keyword3 command">show</span> <span class="quoted">False</span>
    <span class="keyword1 command">by</span> <span class="main">(</span><span class="operator">smt</span> <span class="main main">(</span>verit<span class="main main">,</span><span> del_insts</span><span class="main main">)</span> Rats_inverse <span class="quoted quoted"><span>‹</span><span class="skolem">s</span> <span class="main">≠</span> <span class="main">0</span><span>›</span></span> exp_minus exp_nat_irrational of_int_of_nat<span class="main">)</span>
<span class="keyword1 command">qed</span>
</pre>

